<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[GitBook 博客搭建]]></title>
      <url>/diary/2020/06/17/diary-gitbook/</url>
      <content type="text"><![CDATA[# 搭建环境sudo npm install gitbook-cli  所有的操作都在GitBook目录中完成。我们需要创建一个名为objc-book的书籍。创建电子书的章节目录% mkdir objc-book% cd objc-book % gitbook init# warn: no summary file in this book # info: create README.md # info: create SUMMARY.md # info: initialization is finished   gitbook init 在node 14.0.0环境中报错，用低版本的node。现在的树结构：.└── objc-book    ├── README.md    └── SUMMARY.md  README.md : 默认首页文件,相当于网站的首页index.html,一般是介绍文字或相关导航链接。  SUMMARY.md : 是默认概括文件,主要是根据该文件内容生成相应的目录结构。# Summary## Part I* [Introduction](README.md)* [BASIC](basic.md)	* [BASIC-2](basic.md)		* [BASIC-BASIC-2BASIC-22](basic.md)		## Part I* [Introduction](README.md)* [BASIC](basic.md)	* [BASIC-2](basic.md)----* [Introduction](README.md)运行电子书shanliu@shanliudeMac-mini GitBook % git serve ./objc-book/git: 'serve' is not a git command. See 'git --help'.The most similar command is	mergeshanliu@shanliudeMac-mini GitBook % gitbook serve ./objc-book/Live reload server started on port: 35729Press CTRL+C to quit ...info: 7 plugins are installed info: loading plugin "livereload"... OK info: loading plugin "highlight"... OK info: loading plugin "search"... OK info: loading plugin "lunr"... OK info: loading plugin "sharing"... OK info: loading plugin "fontsettings"... OK info: loading plugin "theme-default"... OK info: found 1 pages info: found 0 asset files info: &gt;&gt; generation finished with success in 0.4s ! Starting server ...Serving book on http://localhost:4000或者直接cd到objc-book根目录下运行。shanliu@shanliudeMac-mini GitBook % cd objc-book shanliu@shanliudeMac-mini objc-book % gitbook serveLive reload server started on port: 35729Press CTRL+C to quit ...info: 7 plugins are installed info: loading plugin "livereload"... OK info: loading plugin "highlight"... OK info: loading plugin "search"... OK info: loading plugin "lunr"... OK info: loading plugin "sharing"... OK info: loading plugin "fontsettings"... OK info: loading plugin "theme-default"... OK info: found 1 pages info: found 0 asset files info: &gt;&gt; generation finished with success in 0.4s ! Starting server ...Serving book on http://localhost:4000不过因为操作都是基于GitBook根目录，所以下面的操作都不会cd到具体的目录。创建资源文件.├── README.md├── SUMMARY.md├── _posts =&gt; 这个文件夹存放文章├── assets =&gt; 这个文件夹存放资源│   ├── csv│   │   └── test.csv│   ├── images│   │   └── favicon.ico│   └── shell│       └── test.sh├── book.json =&gt; 这个文件是配置文件└── website.css =&gt; 这个文件是配置文件配置文件book.json{    "title":"书籍的标题",    "author":"书籍的作者",    "description":"书籍的简要描述.",    "isbn":"书籍的国际标准书号",    "links":{        "sidebar":{            "我的网站1":"https://snowdreams1006.cn/",            "我的网站2":"https://snowdreams1006.cn/"        },        "styles":{            "website":"styles/website.css",            "ebook":"styles/ebook.css",            "pdf":"styles/pdf.css",            "mobi":"styles/mobi.css",            "epub":"styles/epub.css"        }    },    "plugins":[        "simple-page-toc",        "anchor-navigation-ex",        "-lunr",        "-search",        "search-plus",        "advanced-emoji",        "splitter",        "expandable-chapters-small",        "local-video",        "anchors",        "copy-code-button",        "alerts",        "include-csv",        "include-codeblock",        "ace",        "favicon",        "todo"    ],    "pluginsConfig":{        "simple-page-toc":{            "maxDepth":3,            "skipFirstH1":true        },        "anchor-navigation-ex":{            "showLevel":true,            "associatedWithSummary":true,            "printLog":false,            "multipleH1":true,            "mode":"float",            "showGoTop":true,            "float":{                "floatIcon":"fa fa-navicon",                "showLevelIcon":false,                "level1Icon":"fa fa-hand-o-right",                "level2Icon":"fa fa-hand-o-right",                "level3Icon":"fa fa-hand-o-right"            },            "pageTop":{                "showLevelIcon":false,                "level1Icon":"fa fa-hand-o-right",                "level2Icon":"fa fa-hand-o-right",                "level3Icon":"fa fa-hand-o-right"            },            "disqus":{                "shortName":"gitbookuse"            },            "include-codeblock":{                "template":"ace"            },            "favicon":{                "shortcut":"assets/images/favicon.ico",                "bookmark":"assets/images/favicon.ico",                "appleTouch":"assets/images/favicon.ico",                "appleTouchMore":{                    "120x120":"assets/images/favicon.ico",                    "180x180":"assets/images/favicon.ico"                }            }        }    }}安装依赖：gitbook install。发布到GitPage  创建仓库https://github.com/{userName}/objc-book.git。cd ./GitBookgit clone -b gh-pages https://github.com/{userName}/objc-book.git objc-book-gh-pages  创建分支cd objc-book-master # 创建 gh-pages 分支，分支名必须是这个git checkout -b gh-pages# push到远程git push --set-upstream origin gh-pages这样就可以以GitPage的方式访问页面:http://{userName}.github.io/objc-book/  把分支拉取到本地cd ./GitBookgit clone -b gh-pages https://github.com/{userName}/objc-book.git objc-book-gh-pages现在整体的目录结构:GitBook├── objc-book├── objc-book-gh-pages =&gt; 分支└── objc-book-master =&gt; 主干，可以把 objc-book 代码放到主干中，作为日常草稿，等到需要发布到线上时，再 gitbook build 到 gh-pages 分支。  把objc-book目录中的内容移到objc-book-master，上传到仓库。cd ./objc-book-mastergit add .git commit -m "add"git push  发布到 gh-pages 分支cd ./GitBookgitbook build ./objc-book-master ./tmp# 再把 tmp 文件夹中的内容拷贝到 objc-book-gh-pages ，上传到远程仓库。就发布成功了。.gitignore 文件# Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log*lerna-debug.log*# Diagnostic reports (https://nodejs.org/api/report.html)report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage*.lcov# nyc test coverage.nyc_output# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files).grunt# Bower dependency directory (https://bower.io/)bower_components# node-waf configuration.lock-wscript# Compiled binary addons (https://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modules/jspm_packages/_book/# TypeScript v1 declaration filestypings/# TypeScript cache*.tsbuildinfo# Optional npm cache directory.npm# Optional eslint cache.eslintcache# Microbundle cache.rpt2_cache/.rts2_cache_cjs/.rts2_cache_es/.rts2_cache_umd/# Optional REPL history.node_repl_history# Output of 'npm pack'*.tgz# Yarn Integrity file.yarn-integrity# dotenv environment variables file.env.env.test# parcel-bundler cache (https://parceljs.org/).cache# Next.js build output.next# Nuxt.js build / generate output.nuxtdist# Gatsby files.cache/# Comment in the public line in if your project uses Gatsby and *not* Next.js# https://nextjs.org/blog/next-9-1#public-directory-support# public# vuepress build output.vuepress/dist# Serverless directories.serverless/# FuseBox cache.fusebox/# DynamoDB Local files.dynamodb/# TernJS port file.tern-port插件anchor-navigation-ex浮动目录导航{    "plugins":[        "anchor-navigation-ex"    ],    "pluginsConfig":{        "anchor-navigation-ex":{            "showLevel":false,            "associatedWithSummary":true,            "printLog":true,            "multipleH1":true,            "mode":"float",            "float":{                "showLevelIcon":false,                "level1Icon":"fa fa-hand-o-right",                "level2Icon":"fa fa-hand-o-right",                "level3Icon":"fa fa-hand-o-right"            }        }    }}copy-code-button代码复制{"plugins":["copy-code-button"]}simple-page-toc自动生成本页的目录结构{    "plugins" : [        "simple-page-toc"    ],    "pluginsConfig": {        "simple-page-toc": {            "maxDepth": 3,            "skipFirstH1": true        }    }}使用：在需要使用的地方添加&lt;!-- toc --&gt;expandable-chapters-small左侧的章节目录可以折叠plugins: ["expandable-chapters-small"]emphasize浮动目录导航{    "plugins": [        "emphasize"    ]}search-plus支持中文搜索{    "plugins": ["-lunr", "-search", "search-plus"]}资料  GitBook文档（中文版）  GitBook 插件]]></content>
      <categories>
        
          <category> diary </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Masonry]]></title>
      <url>/ios/2020/06/12/ios-masonry/</url>
      <content type="text"><![CDATA[仓库地址官方推荐布局的位置@implementation DIYCustomView- (id)init {    self = [super init];    if (!self) return nil;    // --- Create your views here ---    self.button = [[UIButton alloc] init];    return self;}// tell UIKit that you are using AutoLayout+ (BOOL)requiresConstraintBasedLayout {    return YES;}// this is Apple's recommended place for adding/updating constraints- (void)updateConstraints {    // --- remake/update constraints here    [self.button remakeConstraints:^(MASConstraintMaker *make) {        make.width.equalTo(@(self.buttonSize.width));        make.height.equalTo(@(self.buttonSize.height));    }];    //according to apple super should be called at end of method    [super updateConstraints];}- (void)didTapButton:(UIButton *)button {    // --- Do your changes ie change variables that affect your layout etc ---    self.buttonSize = CGSize(200, 200);    // tell constraints they need updating    [self setNeedsUpdateConstraints];}-(void)layoutSubviews{    [super layoutSubviews];}@end一些属性的讲解activate、deactivateNSArraymake.height.equalTo(@[view1.mas_height, view2.mas_height]);make.height.equalTo(@[view1, view2]);make.left.equalTo(@[view1, @100, view3.right]);greaterThanOrEqualTo、lessThanOrEqualTo  greaterThanOrEqualTo : 小于等于。  lessThanOrEqualTo : 大于等于。//width &gt;= 200 &amp;&amp; width &lt;= 400make.width.greaterThanOrEqualTo(@200);make.width.lessThanOrEqualTo(@400);//creates view.left = view.superview.left + 10make.left.lessThanOrEqualTo(@10)inset、sizeOffset、offset、centerOffset  inset和insets的用法差不多,值为正数时往视图内部偏移，负数则往远离视图的方向偏移。make.size.equalTo(view2).sizeOffset(CGSizeMake(10, -20));make.center.equalTo(view2).centerOffset(CGPointMake(0, 100));insets[self.yellowView mas_makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view).with.offset(10);    make.top.equalTo(self.view).with.offset(10);    make.right.equalTo(self.view).with.offset(-10);    make.bottom.equalTo(self.view).with.offset(-10);}];// 通过insets简化设置内边距的方式[self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {    // 下、右不需要写负号，insets方法中已经为我们做了取反的操作了。    make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));}];firstBaseline、lastBaseline  firstBaseline、lastBaseline就是基线对齐则。leading、trailing、left、right  leading与left，trailing与right 在正常情况下是等价的。animator// 是否在修改约束时通过动画代理@property (nonatomic, copy, readonly) MASConstraint *animator;// 如果OS支持就激活一个NSLayoutConstraint，否则就调用install- (void)activate;// 销毁前面安装或者激活的NSLayoutConstraint- (void)deactivate;//创建一个NSLayoutConstraint并将它添加到合适的view上- (void)install;//移除以前安装的NSLayoutConstraint- (void)uninstall;示例：动态添加控件static UIEdgeInsets padding;static CGFloat height = 100;static int num = 0;@interface MASExampleAutoAddView()@property (nonatomic, strong) UIView *superView;@property (nonatomic, strong) UIView *bottomView;@property (nonatomic, weak) MASConstraint *bottomConstraint;@end@implementation MASExampleAutoAddView- (id)init {    self = [super init];    if (!self) return nil;    padding = UIEdgeInsetsMake(10, 10, 10, 10);        self.superView = [LayoutUtils createView];    [self addSubview:self.superView];    [self.superView makeConstraints:^(MASConstraintMaker *make) {        make.left.right.top.mas_equalTo(padding);    }];        UIButton *tapButton = [LayoutUtils createButtonWithTitle:@"Add" target:self selector:@selector(clickButton:)];    [self.superView addSubview:tapButton];    [tapButton makeConstraints:^(MASConstraintMaker *make) {        make.left.right.top.mas_equalTo(padding);        self.bottomConstraint = make.bottom.mas_equalTo(padding);//记录下这个约束对象        make.height.equalTo(@(height));    }];    self.bottomView = tapButton;        UIView *bottomView = [LayoutUtils createView];    [self.superView addSubview:bottomView];    [bottomView makeConstraints:^(MASConstraintMaker *make) {        make.left.right.mas_equalTo(padding);        make.top.mas_equalTo(self.superView.mas_bottom).mas_equalTo(padding);        make.height.mas_equalTo(@(height));    }];        return self;}-(void)clickButton:(UIButton*)sender{    [self.bottomConstraint uninstall];//卸载旧的底部约束    num += 1;    UILabel *label = [LayoutUtils fixedLabelWithText:[NSString stringWithFormat:@"控件%d", num]];    [self.superView addSubview:label];    [label makeConstraints:^(MASConstraintMaker *make) {        make.left.right.mas_equalTo(padding);        make.top.equalTo(self.bottomView.mas_bottom).mas_equalTo(padding);        self.bottomConstraint = make.bottom.equalTo(self.superView.mas_bottom).mas_equalTo(padding);//添加新的底部约束        make.height.equalTo(@(height));    }];    self.bottomView = label;}@end优先级  priority(value) : 手动设置优先级的数值，优先级最大数值是1000。priority(200)  priorityLow() : 约束优先级-低。  priorityMedium() : 约束优先级-中。priorityMedium()=500  priorityHigh() : 约束优先级-高。// 别挤我- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;// 抱紧，类似于sizefit，不会根据父view长度变化- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;@interface MASTableViewPriorityCell : MASTableViewBasicCell@property (strong, nonatomic) UILabel *leftLabel; // 必须显示完整@property (strong, nonatomic) UILabel *middleLabel; // 可以显示全就显示，显示不全展示(XXXX...)@property (strong, nonatomic) UIButton *rightButton; // rightView 在 middleLabel 的右边，完全显示，不能超过右边屏幕@end@implementation MASTableViewPriorityCell-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        self.selectionStyle = UITableViewCellSelectionStyleNone;                self.leftLabel = [LayoutUtils fixedLabelWithText:@"0万"];        [self.contentView addSubview:self.leftLabel];        [self.leftLabel makeConstraints:^(MASConstraintMaker *make) {            make.left.top.bottom.equalTo(kPadding);        }];                self.middleLabel = [LayoutUtils fixedLabelWithText:@""];        self.middleLabel.numberOfLines = 1;        self.middleLabel.textAlignment = NSTextAlignmentLeft;        [self.contentView addSubview:self.middleLabel];        [self.middleLabel makeConstraints:^(MASConstraintMaker *make) {            make.top.bottom.equalTo(kPadding);            make.left.equalTo(self.leftLabel.mas_right).inset(kPadding.right);        }];        self.rightButton = [LayoutUtils createButtonWithTitle:@"置顶" target:self selector:@selector(buttonClick:)];        [self.contentView addSubview:self.rightButton];        [self.rightButton makeConstraints:^(MASConstraintMaker *make) {            make.top.bottom.equalTo(kPadding);            make.left.equalTo(self.middleLabel.mas_right).inset(kPadding.right);            make.right.lessThanOrEqualTo(self.contentView).inset(kPadding.right);        }];                //宽度不够时，可以被压缩        [self.middleLabel setContentCompressionResistancePriority:UILayoutPriorityFittingSizeLevel forAxis:UILayoutConstraintAxisHorizontal];        // 抱紧        [self.middleLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];        //不可以被压缩，尽量显示完整        [self.leftLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];    }    return self;}-(void)updateData{    self.leftLabel.text = [NSString stringWithFormat:@"%@万",self.cellData.playCount];    self.middleLabel.text = self.cellData.content;}@endlayoutMarginsGuideUIView 有一个UIEdgeInsets 类型的属性 layoutMargins。它表示一个视图的内容和它四个边界之间的空隙。UIView 的 layoutMarginsGuide 属性其实是 layoutMargins 的另一种表现形式，可用于创建布局约束。layoutMarginsGuide 是一个 只读 属性。safeAreaLayoutGuide在 iOS 11 时，苹果提出了 Safe Area 的概念。因为 iOS 11 搭载的 iPhone X 取消了 Home 键，要为操作保留一些空间，这正好把原来的 Navigation Bar, Status Bar, Tab Bar 包含在里面。safeAreaLayoutGuide 属性正是伴随 Safe Area 出现的。safeAreaLayoutGuide 是一个 只读 属性。  Masonry 1.1.0 最新版本对safeAreaLayoutGuide是会crach的。系统布局相关UIView+ (BOOL)requiresConstraintBasedLayout{    return YES;}@property(class, nonatomic, readonly) BOOL requiresConstraintBasedLayout;/// update constraints now so we can animate the change- (void)updateConstraintsIfNeeded; /// this is Apple's recommended place for adding/updating constraints- (void)updateConstraints;- (BOOL)needsUpdateConstraints;/// tell constraints they need updating- (void)setNeedsUpdateConstraints;/// 告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用 layoutSubviews - (void)setNeedsLayout;/// 告知页面布局立刻更新。所以一般都会和 setNeedsLayout 一起使用。如果希望立刻生成新的 frame 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。- (void)layoutIfNeeded;/// 系统重写布局- (void)layoutSubviews;用法：- (void)updateConstraints {    // Layout code here...    [super updateConstraints];}-(void)tap{    [self setNeedsUpdateConstraints];    [self updateConstraintsIfNeeded];    [UIView animateWithDuration:0.4 animations:^{        [self layoutIfNeeded];    }];}// iOS系统最低配为iOS8.0__IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 80000动画安全范围内移动控件@interface MASExampleTouchMoveView()@property (nonatomic, strong) MASConstraint *leftConstraint; // 保存左边的约束，用于在移动时调整位置@property (nonatomic, strong) MASConstraint *topConstraint; // 保存顶部的约束，用于在移动时调整位置@end@implementation MASExampleTouchMoveView- (id)init {    self = [super init];    if (!self) return nil;    UILabel *label = [LayoutUtils fixedLabelWithText:@"Move Me"];    [self addSubview:label];    [label makeConstraints:^(MASConstraintMaker *make) {        self.leftConstraint = make.centerX.equalTo(self.mas_left).with.offset(50).priorityHigh();        self.topConstraint = make.centerY.equalTo(self.mas_top).with.offset(50).priorityHigh();                // 边界条件约束，保证内容可见，优先级1000        make.left.greaterThanOrEqualTo(kPadding);        make.right.lessThanOrEqualTo(kPadding);        make.top.greaterThanOrEqualTo(kPadding);        make.bottom.lessThanOrEqualTo(kPadding);    }];    return self;}-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{    UITouch *touch = [[event allTouches] anyObject];    CGPoint touchLocation = [touch locationInView:self];    NSLog(@"%@",NSStringFromCGPoint(touchLocation));    self.leftConstraint.offset = touchLocation.x;        self.topConstraint.offset = touchLocation.y;}@end更新动画@implementation MASExampleTotalUpdateAnimateView- (id)init {    self = [super init];    if (!self) return nil;        self.superView = [LayoutUtils createView];    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onTap)];    [self.superView addGestureRecognizer:tap];    [self addSubview:self.superView];        self.sonView = [LayoutUtils createView];    [self addSubview:self.sonView];        [self setNeedsUpdateConstraints];        return self;}-(void)updateConstraints{    [self.superView mas_updateConstraints:^(MASConstraintMaker *make) {        make.left.top.equalTo(kPadding);        make.right.equalTo(kPadding);        if (self.isExpanded) {            make.bottom.equalTo(kPadding);        } else {            make.bottom.mas_equalTo(-300);        }    }];        [self.sonView mas_updateConstraints:^(MASConstraintMaker *make) {        make.center.equalTo(self.superView);        // 这里使用优先级处理        // 设置其最大值为250，最小值为90        if (!self.isExpanded) {            make.width.height.mas_equalTo(100 * 0.5).priorityLow();        } else {            make.width.height.mas_equalTo(100 * 3).priorityLow();        }        make.width.height.lessThanOrEqualTo(@250);// 最大值为250        make.width.height.greaterThanOrEqualTo(@90);// 最小值为90    }];        [super updateConstraints];}-(void)onTap{    self.isExpanded = !self.isExpanded;        [self setNeedsUpdateConstraints];    [self updateConstraintsIfNeeded];    [UIView animateWithDuration:0.4 animations:^{        [self layoutIfNeeded];    }];}@end约束放到数组中- (id)init {    self = [super init];    if (!self) return nil;        [blueView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(update)]];    [blueView setUserInteractionEnabled:YES];    UIView *superview = self;    int padding = self.padding = 10;    UIEdgeInsets paddingInsets = UIEdgeInsetsMake(self.padding, self.padding, self.padding, self.padding);    self.animatableConstraints = NSMutableArray.new;    [greenView mas_makeConstraints:^(MASConstraintMaker *make) {        [self.animatableConstraints addObjectsFromArray:@[            make.edges.equalTo(superview).insets(paddingInsets).priorityLow(),            make.bottom.equalTo(blueView.mas_top).offset(-padding),        ]];        make.size.equalTo(redView);        make.height.equalTo(blueView.mas_height);    }];    [redView mas_makeConstraints:^(MASConstraintMaker *make) {        [self.animatableConstraints addObjectsFromArray:@[            make.edges.equalTo(superview).insets(paddingInsets).priorityLow(),            make.left.equalTo(greenView.mas_right).offset(padding),            make.bottom.equalTo(blueView.mas_top).offset(-padding),        ]];        make.size.equalTo(greenView);        make.height.equalTo(blueView.mas_height);    }];    [blueView mas_makeConstraints:^(MASConstraintMaker *make) {        [self.animatableConstraints addObjectsFromArray:@[            make.edges.equalTo(superview).insets(paddingInsets).priorityLow(),        ]];        make.height.equalTo(greenView.mas_height);        make.height.equalTo(redView.mas_height);    }];    return self;}-(void)update{    int padding = self.isChangePadding ? 100 : self.padding;    UIEdgeInsets paddingInsets = UIEdgeInsetsMake(padding, padding, padding, padding);    for (MASConstraint *constraint in self.animatableConstraints) {        constraint.insets = paddingInsets;    }    [UIView animateWithDuration:1 animations:^{        [self layoutIfNeeded];    } completion:^(BOOL finished) {        self.isChangePadding = !self.isChangePadding;    }];}移除-更新约束+ (BOOL)requiresConstraintBasedLayout{    return YES;}- (void)updateConstraints {    [self.movingButton remakeConstraints:^(MASConstraintMaker *make) {        make.width.equalTo(@(100));        make.height.equalTo(@(100));                if (self.topLeft) {            make.left.equalTo(self.left).with.offset(10);            make.top.equalTo(self.top).with.offset(10);        }        else {            make.bottom.equalTo(self.bottom).with.offset(-10);            make.right.equalTo(self.right).with.offset(-10);        }    }];    [super updateConstraints];}- (void)toggleButtonPosition {    self.topLeft = !self.topLeft;        // tell constraints they need updating    [self setNeedsUpdateConstraints];        // update constraints now so we can animate the change    [self updateConstraintsIfNeeded];        [UIView animateWithDuration:0.4 animations:^{        [self layoutIfNeeded];    }];}Masonry 代码示例  makeConstraints: : 添加约束。  updateConstraints: : 更新约束、亦可添加新约束。  remakeConstraints: : 重置之前的约束。  mas_distributeViewsAlongAxis:withFixedSpacing:leadSpacing:tailSpacing:      mas_distributeViewsAlongAxis:withFixedItemLength:leadSpacing:tailSpacing:    multipler : 表示约束值为约束对象的乘因数。  dividedBy : 表示约束值为约束对象的除因数。布局使用结构体make.center.equalTo(CGPointMake(0, 50));make.size.equalTo(CGSizeMake(200, 100));make.edges.equalTo(superview).insets(UIEdgeInsetsMake(self.padding, self.padding, self.padding, self.padding));make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0));make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0));insets的链式使用UIEdgeInsets padding = UIEdgeInsetsMake(15, 10, 15, 10);[greenView mas_makeConstraints:^(MASConstraintMaker *make) {    // chain attributes    make.top.and.left.equalTo(superview).insets(padding);    // which is the equivalent of    // make.top.greaterThanOrEqualTo(superview).insets(padding);    // make.left.greaterThanOrEqualTo(superview).insets(padding);    make.bottom.equalTo(blueView.mas_top).insets(padding);    make.right.equalTo(redView.mas_left).insets(padding);    make.width.equalTo(redView.mas_width);    make.height.equalTo(@[redView, blueView]);}];[redView mas_makeConstraints:^(MASConstraintMaker *make) {    // chain attributes    make.top.and.right.equalTo(superview).insets(padding);    make.left.equalTo(greenView.mas_right).insets(padding);    make.bottom.equalTo(blueView.mas_top).insets(padding);    make.width.equalTo(greenView.mas_width);    make.height.equalTo(@[greenView, blueView]);}];[blueView mas_makeConstraints:^(MASConstraintMaker *make) {    make.top.equalTo(greenView.mas_bottom).insets(padding);    // chain attributes    make.left.right.and.bottom.equalTo(superview).insets(padding);    make.height.equalTo(@[greenView, redView]);}];约束@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;@property (nonatomic, strong, readonly) MASConstraint *bottom;@property (nonatomic, strong, readonly) MASConstraint *leading;@property (nonatomic, strong, readonly) MASConstraint *trailing;@property (nonatomic, strong, readonly) MASConstraint *width;@property (nonatomic, strong, readonly) MASConstraint *height;@property (nonatomic, strong, readonly) MASConstraint *centerX;@property (nonatomic, strong, readonly) MASConstraint *centerY;@property (nonatomic, strong, readonly) MASConstraint *baseline;@property (nonatomic, strong, readonly) MASConstraint *firstBaseline;@property (nonatomic, strong, readonly) MASConstraint *lastBaseline;@property (nonatomic, strong, readonly) MASConstraint *leftMargin;@property (nonatomic, strong, readonly) MASConstraint *rightMargin;@property (nonatomic, strong, readonly) MASConstraint *topMargin;@property (nonatomic, strong, readonly) MASConstraint *bottomMargin;@property (nonatomic, strong, readonly) MASConstraint *leadingMargin;@property (nonatomic, strong, readonly) MASConstraint *trailingMargin;@property (nonatomic, strong, readonly) MASConstraint *centerXWithinMargins;@property (nonatomic, strong, readonly) MASConstraint *centerYWithinMargins;@property (nonatomic, strong, readonly) MASConstraint *edges;@property (nonatomic, strong, readonly) MASConstraint *size;@property (nonatomic, strong, readonly) MASConstraint *center;等宽高布局  不管父视图如何布局，子视图内部都是等宽高的布局。UIView *superview = self;int padding = 10;[greenView makeConstraints:^(MASConstraintMaker *make) {    make.top.greaterThanOrEqualTo(superview.top).offset(padding);    make.left.equalTo(superview.left).offset(padding);    make.bottom.equalTo(blueView.top).offset(-padding);    make.right.equalTo(redView.left).offset(-padding);    make.width.equalTo(redView.width);    make.height.equalTo(redView.height);    make.height.equalTo(blueView.height);    }];//with is semantic and option[redView mas_makeConstraints:^(MASConstraintMaker *make) {    make.top.equalTo(superview.mas_top).with.offset(padding); //with with    make.left.equalTo(greenView.mas_right).offset(padding); //without with    make.bottom.equalTo(blueView.mas_top).offset(-padding);    make.right.equalTo(superview.mas_right).offset(-padding);    make.width.equalTo(greenView.mas_width);        make.height.equalTo(@[greenView, blueView]); //can pass array of views}];[blueView mas_makeConstraints:^(MASConstraintMaker *make) {    make.top.equalTo(greenView.mas_bottom).offset(padding);    make.left.equalTo(superview.mas_left).offset(padding);    make.bottom.equalTo(superview.mas_bottom).offset(-padding);    make.right.equalTo(superview.mas_right).offset(-padding);    make.height.equalTo(@[greenView.mas_height, redView.mas_height]); //can pass array of attributes}];混合布局UIView *lastView = self;for (int i = 0; i &lt; 10; i++) {    UIView *view = UIView.new;    view.backgroundColor = [self randomColor];    view.layer.borderColor = UIColor.blackColor.CGColor;    view.layer.borderWidth = 2;    [self addSubview:view];        [view mas_makeConstraints:^(MASConstraintMaker *make) {        make.edges.equalTo(lastView).insets(UIEdgeInsetsMake(5, 10, 15, 20));    }];        lastView = view;}Masonry Aspect- (instancetype)initWithFrame:(CGRect)frame{    self = [super initWithFrame:CGRectZero];    multipliedBy = 1;        if (self) {                // Create views        self.topView = [[UIView alloc] initWithFrame:CGRectZero];        self.topInnerView = [[UIView alloc] initWithFrame:CGRectZero];        self.bottomView = [[UIView alloc] initWithFrame:CGRectZero];        self.bottomInnerView = [[UIView alloc] initWithFrame:CGRectZero];                [self.topInnerView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(update)]];        [self.topInnerView setUserInteractionEnabled:YES];                        // Set background colors        UIColor *blueColor = [UIColor colorWithRed:0.663 green:0.796 blue:0.996 alpha:1];        [self.topView setBackgroundColor:blueColor];        UIColor *lightGreenColor = [UIColor colorWithRed:0.784 green:0.992 blue:0.851 alpha:1];        [self.topInnerView setBackgroundColor:lightGreenColor];        UIColor *pinkColor = [UIColor colorWithRed:0.992 green:0.804 blue:0.941 alpha:1];        [self.bottomView setBackgroundColor:pinkColor];                UIColor *darkGreenColor = [UIColor colorWithRed:0.443 green:0.780 blue:0.337 alpha:1];        [self.bottomInnerView setBackgroundColor:darkGreenColor];                // 顶部(topView)、底部(bottomView) View 高度均分。        [self addSubview:self.topView];        [self.topView mas_makeConstraints:^(MASConstraintMaker *make) {            make.left.right.and.top.equalTo(self);        }];                [self addSubview:self.bottomView];        [self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) {            make.left.right.and.bottom.equalTo(self);            make.top.equalTo(self.topView.mas_bottom);            make.height.equalTo(self.topView);        }];        // Inner views are configured for aspect fit with ratio of 3:1        [self.topView addSubview:self.topInnerView];        [self.topInnerView mas_makeConstraints:^(MASConstraintMaker *make) {            // 宽度是其自身高度的三倍            make.width.equalTo(self.topInnerView.mas_height).multipliedBy(multipliedBy);                        // 宽度和高度都不超过其父视图的宽度和高度            make.width.and.height.lessThanOrEqualTo(self.topView);            // 宽度和高度等于其父视图的宽度 优先级低            make.width.and.height.equalTo(self.topView).with.priorityLow();            make.center.equalTo(self.topView);        }];        [self.bottomView addSubview:self.bottomInnerView];        [self.bottomInnerView mas_makeConstraints:^(MASConstraintMaker *make) {            //高度等于其自身宽度的3倍            make.height.equalTo(self.bottomInnerView.mas_width).multipliedBy(3);                        // 宽度和高度都不超过其父视图的宽度和高度            make.width.and.height.lessThanOrEqualTo(self.bottomView);            // 宽度和高度等于其父视图的宽度 优先级低            make.width.and.height.equalTo(self.bottomView).with.priorityLow();            make.center.equalTo(self.bottomView);        }];    }        return self;}+(BOOL)requiresConstraintBasedLayout{    return YES;}-(void)updateConstraints{    [self.topInnerView remakeConstraints:^(MASConstraintMaker *make) {        //1. 确定坐标        make.center.equalTo(self.topView);        //2. 宽度和高度等于其父视图的宽度 优先级低        make.width.and.height.equalTo(self.topView).with.priorityLow();        //3. 宽度是其自身高度的三倍        make.width.equalTo(self.topInnerView.mas_height).multipliedBy(self-&gt;multipliedBy);// width=height*4 ==&gt; width/height=4/1        //4. 宽度和高度都不超过其父视图的宽度和高度        make.width.and.height.lessThanOrEqualTo(self.topView);    }];    [super updateConstraints];}-(void)update{    multipliedBy += 1;    NSLog(@"%f",multipliedBy);    [self setNeedsUpdateConstraints];    [self updateConstraintsIfNeeded];    [UIView animateWithDuration:0.4 animations:^{        [self layoutIfNeeded];    }];}给Masonry添加Debug  当约束冲突时，打印的日志比较难定位是哪些控件的约束或者说是哪条约束，Masonry已经给我们提供了相关的方法:MASAttachKeys()、给约束设置key。greenView.mas_key = @"greenView";MASAttachKeys(greenView, redView, blueView, superview);[blueView mas_makeConstraints:^(MASConstraintMaker *make) {    //you can also attach debug keys to constaints    make.edges.equalTo(@1).key(@"ConflictingConstraint"); //composite constraint keys will be indexed    make.height.greaterThanOrEqualTo(@5000).key(@"ConstantConstraint");    make.top.equalTo(greenView.mas_bottom).offset(padding);    make.left.equalTo(superview.mas_left).offset(padding);    make.bottom.equalTo(superview.mas_bottom).offset(-padding).key(@"BottomConstraint");    make.right.equalTo(superview.mas_right).offset(-padding);    make.height.equalTo(greenView.mas_height);    make.height.equalTo(redView.mas_height).key(@340954); //anything can be a key}];// 添加Debug前"&lt;MASLayoutConstraint:ConstantConstraint UILabel:0x7f82ef709550.height &gt;= 5000&gt;","&lt;MASLayoutConstraint:ConflictingConstraint[2] UILabel:0x7f82ef709550.top == MASExampleDebuggingView:0x7f82ef422490.top + 1&gt;","&lt;MASLayoutConstraint:0x600003756f40 UILabel:0x7f82ef709550.top == UIView:0x7f82ef717f10.bottom + 10&gt;","&lt;MASLayoutConstraint:0x60000375e1c0 UILabel:0x7f82ef709550.height == UIView:0x7f82ef717f10.height&gt;","&lt;MASLayoutConstraint:0x60000375e520 UIView:0x7f82ef717f10.top &gt;= MASExampleDebuggingView:0x7f82ef422490.top + 10&gt;"// 添加Debug后"&lt;MASLayoutConstraint:ConstantConstraint UILabel:blueView.height &gt;= 5000&gt;","&lt;MASLayoutConstraint:ConflictingConstraint[2] UILabel:blueView.top == MASExampleDebuggingView:superview.top + 1&gt;","&lt;MASLayoutConstraint:0x600003b2d800 UILabel:blueView.top == UIView:greenView.bottom + 10&gt;","&lt;MASLayoutConstraint:0x600003b2d6e0 UILabel:blueView.height == UIView:greenView.height&gt;","&lt;MASLayoutConstraint:0x600003b2d9e0 UIView:greenView.top &gt;= MASExampleDebuggingView:superview.top + 10&gt;"UILabel布局多行UILabelstatic UIEdgeInsets const kPadding = {10, 10, 10, 10};- (id)init {    self = [super init];    if (!self) return nil;    self.longLabel.lineBreakMode = NSLineBreakByTruncatingTail;    self.longLabel.text = @"Bacon ipsum dolor sit amet spare ribs fatback kielbasa salami, tri-tip jowl pastrami flank short loin rump sirloin. Tenderloin frankfurter chicken biltong rump chuck filet mignon pork t-bone flank ham hock.";        [self.longLabel makeConstraints:^(MASConstraintMaker *make) {        make.left.equalTo(self.left).insets(kPadding);        make.top.equalTo(self.top).insets(kPadding);    }];    [self.shortLabel makeConstraints:^(MASConstraintMaker *make) {        make.top.equalTo(self.longLabel.lastBaseline);        make.right.equalTo(self.right).insets(kPadding);    }];    return self;}- (void)layoutSubviews {    [super layoutSubviews];    // for multiline UILabel's you need set the preferredMaxLayoutWidth    // you need to do this after [super layoutSubviews] as the frames will have a value from Auto Layout at this point    // stay tuned for new easier way todo this coming soon to Masonry    CGFloat width = CGRectGetMinX(self.shortLabel.frame) - kPadding.left;    width -= CGRectGetMinX(self.longLabel.frame);    self.longLabel.preferredMaxLayoutWidth = width;    // need to layoutSubviews again as frames need to recalculated with preferredLayoutWidth    [super layoutSubviews];}UILabel自适应宽度/高度@interface MASExampleMulLabelAutoSizeView()@property (nonatomic, strong) UILabel *label;@end@implementation MASExampleMulLabelAutoSizeView- (id)init {    self = [super init];    if (!self) return nil;        self.label = [LayoutUtils fixedLabelWithText:@"最近是用Masonry自动布局UILabel的时候，;这些东西之后，label还是没有换行。最近是用Masonry自动布局UILabel的时候，"];    self.label.textAlignment = NSTextAlignmentLeft;    [self addSubview:self.label];    [self.label mas_makeConstraints:^(MASConstraintMaker *make) {        make.top.mas_equalTo(100);        make.left.mas_equalTo(15);    }];        UIButton *button = [LayoutUtils createButtonWithTitle:@"添加文字" target:self selector:@selector(clickButton:)];    [self addSubview:button];    [button mas_makeConstraints:^(MASConstraintMaker *make) {        make.top.mas_equalTo(self.label.mas_bottom).mas_offset(20);        make.centerX.mas_equalTo(self);        make.height.mas_equalTo(50);        make.width.mas_lessThanOrEqualTo(300);    }];        return self;}-(void)clickButton:(UIButton*)sender{    self.label.text = [self.label.text stringByAppendingString:@"Masonry自动布局YYLabel"];}-(void)layoutSubviews{    [super layoutSubviews];    self.label.preferredMaxLayoutWidth = CGRectGetWidth(self.frame) - 30;}@endUIScrollView布局  在使用Masonry对UIScrollView设置约束后，contentSize属性就不管用了，需要通过Masonry的规则在scrollView中添加一个contentView,其它的子视图全部添加到 contentView 上，让contentView来撑起UIScrollview的contentSize。垂直方向@interface MASExampleScrollView ()@property (strong, nonatomic) UIScrollView* scrollView;@end@implementation MASExampleScrollView- (id)init {    self = [super init];    if (!self) return nil;        UIScrollView *scrollView = UIScrollView.new;    self.scrollView = scrollView;    scrollView.backgroundColor = [UIColor grayColor];    [self addSubview:scrollView];    [self.scrollView makeConstraints:^(MASConstraintMaker *make) {        make.edges.equalTo(self);    }];        [self generateContent];    return self;}- (void)generateContent {    UIView* contentView = UIView.new;    [self.scrollView addSubview:contentView];        [contentView makeConstraints:^(MASConstraintMaker *make) {        make.edges.equalTo(self.scrollView);        make.width.equalTo(self.scrollView);    }];        UIView *lastView;    CGFloat height = 25;        for (int i = 0; i &lt; 10; i++) {        UIView *view = UIView.new;        view.backgroundColor = [self randomColor];        [contentView addSubview:view];                UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTap:)];        [view addGestureRecognizer:singleTap];                [view mas_makeConstraints:^(MASConstraintMaker *make) {            make.top.equalTo(lastView ? lastView.bottom : @0);            make.left.equalTo(@0);            make.width.equalTo(contentView.width);            make.height.equalTo(@(height));        }];                height += 25;        lastView = view;    }        [contentView makeConstraints:^(MASConstraintMaker *make) {        make.bottom.equalTo(lastView.bottom);    }];}- (UIColor *)randomColor {    CGFloat hue = ( arc4random() % 256 / 256.0 );  //  0.0 to 1.0    CGFloat saturation = ( arc4random() % 128 / 256.0 ) + 0.5;  //  0.5 to 1.0, away from white    CGFloat brightness = ( arc4random() % 128 / 256.0 ) + 0.5;  //  0.5 to 1.0, away from black    return [UIColor colorWithHue:hue saturation:saturation brightness:brightness alpha:1];}- (void)singleTap:(UITapGestureRecognizer*)sender {    [sender.view setAlpha:sender.view.alpha / 1.20]; // To see something happen on screen when you tap :O    [self.scrollView scrollRectToVisible:sender.view.frame animated:YES];};@end水平方向static UIEdgeInsets padding;@implementation MASExampleScrollHorView- (id)init {    self = [super init];    if (!self) return nil;    padding = UIEdgeInsetsMake(10, 10, 10, 10);        UIScrollView *scrollView = [LayoutUtils creatUIScrollView];    [self addSubview:scrollView];    [scrollView makeConstraints:^(MASConstraintMaker *make) {        make.edges.mas_equalTo(padding); // make.edges.equalTo(self).mas_equalTo(padding);    }];        // 设置scrollView的子视图，即过渡视图contentSize    UIView* contentView = [LayoutUtils createView];    [scrollView addSubview:contentView];    [contentView makeConstraints:^(MASConstraintMaker *make) {        make.edges.equalTo(scrollView);        make.height.equalTo(scrollView);    }];        // 动态添加子视图到 contentView 上    UIView *lastView = nil;    for (int i = 0; i &lt;= 10; i++) {        UILabel *label = [LayoutUtils fixedLabelWithText:[NSString stringWithFormat:@"水平方向\n第 %d 个视图", (i + 1)]];        [contentView addSubview:label];        [label makeConstraints:^(MASConstraintMaker *make) {            make.top.bottom.mas_equalTo(padding);            make.width.equalTo(scrollView).offset(-(padding.left+padding.right));            if (lastView) {                make.left.mas_equalTo(lastView.mas_right).offset(padding.left+padding.right);            } else {                make.left.mas_equalTo(padding);            }        }];        lastView = label;    }    [contentView mas_makeConstraints:^(MASConstraintMaker *make) {        make.right.mas_equalTo(lastView.mas_right).offset(padding.left+padding.right);    }];        return self;}@endArray的Button数组- (id)init {    self = [super init];    if (!self) return nil;    [lowerButton mas_makeConstraints:^(MASConstraintMaker *make) {        make.left.equalTo(self).with.offset(10.0);    }];    [centerButton mas_makeConstraints:^(MASConstraintMaker *make) {        make.centerX.equalTo(self);    }];    [raiseButton mas_makeConstraints:^(MASConstraintMaker *make) {        make.right.equalTo(self).with.offset(-10);    }];    self.buttonViews = @[ raiseButton, lowerButton, centerButton ];    return self;}- (void)centerAction {    self.offset = 0.0;}- (void)raiseAction {    self.offset -= kArrayExampleIncrement;}- (void)lowerAction {    self.offset += kArrayExampleIncrement;}- (void)setOffset:(CGFloat)offset {    _offset = offset;    [self setNeedsUpdateConstraints];}- (void)updateConstraints {    [self.buttonViews updateConstraints:^(MASConstraintMaker *make) {        make.baseline.equalTo(self.mas_centerY).with.offset(self.offset);    }];    [super updateConstraints];}layoutMarginsmas_distributeViewsAlongAxis[arr mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:20 leadSpacing:5 tailSpacing:5];[arr makeConstraints:^(MASConstraintMaker *make) {    make.top.equalTo(@60);    make.height.equalTo(@60);}];[arr mas_distributeViewsAlongAxis:MASAxisTypeVertical withFixedSpacing:20 leadSpacing:5 tailSpacing:5];[arr makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(@0);    make.width.equalTo(@60);}];[arr mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedItemLength:30 leadSpacing:200 tailSpacing:30];[arr makeConstraints:^(MASConstraintMaker *make) {    make.top.equalTo(@60);    make.height.equalTo(@60);}];[arr mas_distributeViewsAlongAxis:MASAxisTypeVertical withFixedItemLength:30 leadSpacing:30 tailSpacing:200];[arr makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(@0);    make.width.equalTo(@60);}];+ (BOOL)requiresConstraintBasedLayout {    return YES;}- (id)init {    self = [super init];    if (!self) return nil;        NSLog(@"%s:%@",__FUNCTION__,NSStringFromCGRect(self.frame));        UIView *contentView = [LayoutUtils createView];    [self addSubview:contentView];    [contentView makeConstraints:^(MASConstraintMaker *make) {        make.top.equalTo(self).offset(@(20));        make.left.right.equalTo(self);    }];        UIView *lastView = nil;        NSInteger itemsCount = 11;    NSInteger rowCount = 3;// 设置每行有4个Item    NSInteger rowNum = (itemsCount/rowCount) + ((NSInteger)(itemsCount%rowCount&gt;0));//显示的总行数    NSInteger itemHeight = 80;        for (int j = 0; j &lt; rowNum; j++) {                NSMutableArray&lt;UILabel*&gt; *rowArray = [NSMutableArray array];                for (int i = 0; i &lt; rowCount; i++) {            NSInteger index = j*rowCount+i;            UILabel *label = [LayoutUtils fixedLabelWithText:[NSString stringWithFormat:@"content:%zd",index]];            [contentView addSubview:label];            [rowArray addObject:label];            lastView = label;                        if (index &gt; itemsCount - 1) {                label.text = @"";                [label setBackgroundColor:UIColor.clearColor];            }        }        if (rowArray.count &gt; 0) {            [rowArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:15 leadSpacing:10 tailSpacing:10];            [rowArray makeConstraints:^(MASConstraintMaker *make) {                make.top.equalTo(@((itemHeight+20)*j));                make.height.equalTo(@(itemHeight));            }];        }    }        if (lastView) {        [contentView makeConstraints:^(MASConstraintMaker *make) {            make.bottom.mas_equalTo(lastView.mas_bottom);        }];    }        UIView *bottomView = [LayoutUtils createView];    [self addSubview:bottomView];    [bottomView makeConstraints:^(MASConstraintMaker *make) {        make.top.equalTo(contentView.mas_bottom).offset(@(20));        make.left.right.equalTo(self);        make.height.equalTo(@(40));    }];    return self;}多行label的约束问题?  preferredMaxLayoutWidth: 多行label的约束问题。// 已经确认好了位置// 在layoutSubviews中确认label的preferredMaxLayoutWidth值- (void)layoutSubviews {    [super layoutSubviews];    // 你必须在 [super layoutSubviews] 调用之后，longLabel的frame有值之后设置preferredMaxLayoutWidth    self.longLabel.preferredMaxLayoutWidth = self.frame.size.width-100;    // 设置preferredLayoutWidth后，需要重新布局    [super layoutSubviews];}multipler、dividedBy[view makeConstraints:^(MASConstraintMaker *make) {    make.center.equalTo(self);    make.width.equalTo(view.mas_height).multipliedBy(2); // width = height*2 ==&gt; height = width/2    //make.height.equalTo(view.mas_width).dividedBy(2);// height = width/2    make.width.and.height.equalTo(self).width.priorityLow();}];UITableViewUITableViewDataSource// ================= MASTableViewDataSorceImpl ====================@interface MASTableViewDataSorceImpl : NSObject&lt;UITableViewDataSource&gt;@property (strong, nonatomic) NSArray *dataSource;@end@implementation MASTableViewDataSorceImpl- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{    return self.dataSource.count;}-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{    return [MASTableViewNormalCell cellWithTableView:tableView indexPath:indexPath];}@end// ================= MASTableViewDataSorceSubImpl ====================@interface MASTableViewDataSorceSubImpl : MASTableViewDataSorceImpl@end@implementation MASTableViewDataSorceSubImpl-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{    MASTableViewNormalCell *cell = [MASTableViewNormalCell cellWithTableView:tableView indexPath:indexPath];    cell.titleLabel.text = self.dataSource[indexPath.row];    return cell;}@endMASTableViewNormalCell// ================= .h ====================@interface MASTableViewNormalCell : UITableViewCell@property (strong, nonatomic) NSIndexPath *indexPath;@property (strong, nonatomic) UILabel *titleLabel;+(NSString*)reuseIdentifier;+(MASTableViewNormalCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath;@end// ================= .m ====================static UIEdgeInsets const kPadding = {10, 10, 10, 10};@implementation MASTableViewNormalCell#pragma mark - Init Views+(NSString*)reuseIdentifier{    return NSStringFromClass([self class]);}+(MASTableViewNormalCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{    MASTableViewNormalCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier]];    if (!cell) {        cell = [[MASTableViewNormalCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]];    }    return cell;}-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        self.selectionStyle =UITableViewCellSelectionStyleNone;        [self.contentView addSubview:self.titleLabel];                [self.titleLabel makeConstraints:^(MASConstraintMaker *make) {            make.left.top.right.bottom.equalTo(self.contentView).insets(kPadding); // 关键代码        }];    }    return self;}-(UILabel *)titleLabel{    if (!_titleLabel) {        _titleLabel = [[UILabel alloc] init];        [_titleLabel setLineBreakMode:NSLineBreakByWordWrapping];        [_titleLabel setTextAlignment:NSTextAlignmentLeft];        [_titleLabel setNumberOfLines:0];        [_titleLabel setTextColor:UIColor.blackColor];    }    return _titleLabel;}#pragma mark setter@endUITableView@interface MASExampleTableView()@property (strong, nonatomic) UITableView *tableView;@property (strong, nonatomic) MASTableViewDataSorceSubImpl *dataSource;@property (strong, nonatomic) NSArray *data;@end@implementation MASExampleTableView- (instancetype)init {    if (self == [super init]) {        self.dataSource = [MASTableViewDataSorceSubImpl new];        self.dataSource.dataSource = self.data;                [self addSubview:self.tableView];        self.tableView.dataSource = self.dataSource;        self.tableView.delegate = self.delegate;        [self.tableView reloadData];                [self.tableView makeConstraints:^(MASConstraintMaker *make) {            make.edges.equalTo(self);        }];    }    return self;}-(UITableView *)tableView{    if (!_tableView) {        _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];        _tableView.estimatedRowHeight = 44;        _tableView.rowHeight = UITableViewAutomaticDimension;//默认值可省略。    }    return _tableView;}@end外部的部分靠内部支撑UIView *superView = [LayoutUtils createView];UIButton *tapButton = [LayoutUtils createButtonWithTitle:@"Add" selector:@selector(add)];UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[superView addSubview:tapButton];[superView makeConstraints:^(MASConstraintMaker *make) {    make.left.right.top.mas_equalTo(padding); // 父控件只适配了left.right.top的边距，bottom的的距离根据其内子控件的 bottom}];[tapButton makeConstraints:^(MASConstraintMaker *make) {    make.left.right.top.mas_equalTo(padding);    make.bottom.mas_equalTo(padding);//     make.height.equalTo(@(100));}];UIButton自适应宽度- (id)init {    self = [super init];    if (!self) return nil;        UIButton *button = [LayoutUtils createButtonWithTitle:@"UIButton宽度" target:self selector:@selector(clickButton:)];    [self addSubview:button];    [button mas_makeConstraints:^(MASConstraintMaker *make) {        make.center.mas_equalTo(self);        //make.height.mas_equalTo(@[button.titleLabel.mas_height,button.imageView.mas_height]);        make.height.mas_equalTo(@[button.titleLabel.mas_height]);        make.width.mas_lessThanOrEqualTo(300);    }];    return self;}-(void)clickButton:(UIButton*)sender{    [sender setTitle:[sender.currentTitle stringByAppendingString:@"自适应"] forState:UIControlStateNormal];}UITableView九宫格@implementation MASTableViewImagesCell-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        self.selectionStyle = UITableViewCellSelectionStyleNone;        _imagesArr = [NSArray array];        self.picContentView = [LayoutUtils createView];        [self.contentView addSubview:self.picContentView];        [self.picContentView makeConstraints:^(MASConstraintMaker *make) {            make.left.top.right.equalTo(self.contentView);        }];                self.bottomView = [LayoutUtils createView];        [self.contentView addSubview:self.bottomView];        [self.bottomView makeConstraints:^(MASConstraintMaker *make) {            make.top.equalTo(self.picContentView.mas_bottom).insets(kPadding);            make.height.equalTo(@100);            make.left.bottom.right.equalTo(kPadding);        }];    }    return self;}-(void)updateData{    NSLog(@"%s",__func__);    if (self.cellData.imgs &amp;&amp; self.cellData.imgs.length &gt; 0) {        NSString *temptString = self.cellData.imgs;        if ([[temptString substringFromIndex:temptString.length-1] isEqualToString:@","]) {            temptString = [temptString substringToIndex:[temptString length]-1];        }        self.imagesArr = [temptString componentsSeparatedByString:@","];        [self createPicView:self.imagesArr.count];    }}- (void)createPicView:(NSInteger)itemNum {    if (itemNum &lt;= 0) return;        for (UIView *object in self.picContentView.subviews) {        [object removeFromSuperview];    }        //假设要显示 num 个item    NSInteger num = itemNum;    //每行显示的个数    NSInteger count = 3;    //显示的总行数    NSInteger rowNum = (num/count) + ((NSInteger)(num%count&gt;0));        UIView *lastView = nil;    for (int i = 0; i &lt; rowNum; i ++) {        NSMutableArray *masonryViewArray = [NSMutableArray array];        for (int j = 0; j &lt; count; j ++) {            NSInteger currentIndex = i * count + j;                        UIView *view = [LayoutUtils createView];            if (currentIndex &gt; num-1) {                view.backgroundColor = [UIColor clearColor];                view.layer.borderColor = [UIColor clearColor].CGColor;            }            [self.picContentView addSubview:view];                        [masonryViewArray addObject:view];            lastView = view;        }        // 固定 item 之间的间距，item 的宽或者高自动缩放        [masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:15 leadSpacing:kPadding.left tailSpacing:kPadding.right];        // 设置array的垂直方向的约束        [masonryViewArray makeConstraints:^(MASConstraintMaker *make) {            make.top.equalTo(@((100 * i) + kPadding.top));            make.height.equalTo(@80).priorityLow();        }];    }    [self.picContentView makeConstraints:^(MASConstraintMaker *make) {        make.bottom.equalTo(lastView.mas_bottom).priorityLow();    }];}@endUITableView 折叠、展开@interface MASTableViewProfieCell()@property (strong, nonatomic) MASConstraint* masHeight;@end@implementation MASTableViewProfieCell-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        self.selectionStyle = UITableViewCellSelectionStyleNone;                self.headImageView = [LayoutUtils createView];        self.headImageView.layer.cornerRadius = 30;        self.headImageView.layer.masksToBounds = YES;        [self.contentView addSubview:self.headImageView];        [self.headImageView makeConstraints:^(MASConstraintMaker *make) {            make.width.equalTo(@60);            make.height.equalTo(@60).priorityLow();            make.left.top.equalTo(kPadding);        }];        [self.headImageView setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];                self.titleLabel = [LayoutUtils fixedLabelWithText:@""];        [self.contentView addSubview:self.titleLabel];        self.titleLabel.numberOfLines = 1;        [self.titleLabel makeConstraints:^(MASConstraintMaker *make) {            make.top.equalTo(kPadding);            make.left.equalTo(self.headImageView.mas_right).insets(kPadding);            make.right.lessThanOrEqualTo(kPadding);        }];                        self.descabel = [LayoutUtils fixedLabelWithText:@""];        self.descabel.textAlignment = NSTextAlignmentLeft;        [self.contentView addSubview:self.descabel];        [self.descabel makeConstraints:^(MASConstraintMaker *make) {            make.left.equalTo(self.headImageView.mas_right).insets(kPadding);            make.top.equalTo(self.headImageView.mas_centerY);            make.right.lessThanOrEqualTo(kPadding);                        make.bottom.equalTo(kPadding);            make.bottom.greaterThanOrEqualTo(self.headImageView);            //self.masHeight = make.height.lessThanOrEqualTo(@100);        }];            }    return self;}-(void)updateData{    self.titleLabel.text = self.cellData.content;    self.descabel.text = self.cellData.content;    if (self.cellData.isExpended) {        NSLog(@"==1==");        //[self.masHeight uninstall];        self.descabel.numberOfLines = 0;    }else{        NSLog(@"==2==");        //[self.masHeight install];        self.descabel.numberOfLines = 3;    }        [super updateData];}@end另外一种布局约束，既可以解决headImageView.bottom&lt;-cell.bottom cell的底部必须超过heaImageView，同时如果descLabel.bottom&lt;-cell.bottom cell的底部必须超过descLabel；也支持折叠、展开。@interface MASTableViewProfieCell()@property (strong, nonatomic) MASConstraint* masHeight;@end@implementation MASTableViewProfieCell-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        self.selectionStyle = UITableViewCellSelectionStyleNone;                self.headImageView = [LayoutUtils createView];        self.headImageView.layer.cornerRadius = 30;        self.headImageView.layer.masksToBounds = YES;        [self.contentView addSubview:self.headImageView];        [self.headImageView makeConstraints:^(MASConstraintMaker *make) {            make.width.equalTo(@60);            make.height.equalTo(@60).priorityLow();            make.left.top.equalTo(kPadding);            make.bottom.lessThanOrEqualTo(kPadding); //关键代码        }];        [self.headImageView setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];                self.titleLabel = [LayoutUtils fixedLabelWithText:@""];        [self.contentView addSubview:self.titleLabel];        self.titleLabel.numberOfLines = 1;        [self.titleLabel makeConstraints:^(MASConstraintMaker *make) {            make.top.equalTo(kPadding);            make.left.equalTo(self.headImageView.mas_right).insets(kPadding);            make.right.lessThanOrEqualTo(kPadding);        }];                        self.descabel = [LayoutUtils fixedLabelWithText:@""];        self.descabel.textAlignment = NSTextAlignmentLeft;        [self.contentView addSubview:self.descabel];        [self.descabel makeConstraints:^(MASConstraintMaker *make) {            make.left.equalTo(self.headImageView.mas_right).insets(kPadding);            make.top.equalTo(self.headImageView.mas_centerY);            make.right.lessThanOrEqualTo(kPadding);                        //make.bottom.equalTo(kPadding);            self.masHeight = make.height.lessThanOrEqualTo(@100); //关键代码            //make.bottom.greaterThanOrEqualTo(self.headImageView);            make.bottom.lessThanOrEqualTo(kPadding); //关键代码        }];            }    return self;}-(void)updateData{    self.titleLabel.text = self.cellData.content;    self.descabel.text = self.cellData.content;    if (self.cellData.isExpended) {        NSLog(@"==1==");        [self.masHeight uninstall]; //关键代码        self.descabel.numberOfLines = 0;    }else{        NSLog(@"==2==");        [self.masHeight install]; //关键代码        self.descabel.numberOfLines = 3;    }        [super updateData];}-(void)updateConstraints{    [super updateConstraints];}@end资料  系统理解 iOS 自动布局]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[UIStackView]]></title>
      <url>/ios/2020/06/12/ios-UIStackView/</url>
      <content type="text"><![CDATA[  系统：9.0以上。UIStackView像一个容器，类似于UITableView，UICollectionView。仓库地址创建初始化方式：- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views;@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *arrangedSubviews;UIStackView *sv = [LayoutUtils creatStackView];[self addSubview:sv];UIView *subView1 = [LayoutUtils createView];UIView *subView2 = [LayoutUtils createView];// 子View 实例加到 UIStackView 里[sv addArrangedSubview:subView1];[sv addArrangedSubview:subView2];NSArray&lt;UIView *&gt; *arrangedSubviews = sv.arrangedSubviews;NSLog(@"%@",arrangedSubviews);/*2020-06-12 09:39:59.898694+0800 MasonryExample[65963:3203047] (    "&lt;UIView: 0x7fcb28c40940; frame = (0 0; 0 0); layer = &lt;CALayer: 0x6000039cfd60&gt;&gt;",    "&lt;UIView: 0x7fcb28c40ab0; frame = (0 0; 0 0); layer = &lt;CALayer: 0x6000039cfda0&gt;&gt;")*/UILabel *subLabel1 = [LayoutUtils fixedLabelWithText:@"Sub1"];UILabel *subLabel2 = [LayoutUtils fixedLabelWithText:@"Sub2"];UIStackView *sv = [[UIStackView alloc] initWithArrangedSubviews:@[subLabel1,subLabel2]];[self addSubview:sv];NSArray&lt;UIView *&gt; *arrangedSubviews = sv.arrangedSubviews;NSLog(@"%@",arrangedSubviews);/*2020-06-12 09:42:19.734773+0800 MasonryExample[66066:3204972] (    "&lt;UILabel: 0x7f909d73d010; frame = (0 0; 0 0); text = 'Sub1'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x600000803200&gt;&gt;",    "&lt;UILabel: 0x7f909d7430b0; frame = (0 0; 0 0); text = 'Sub2'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x6000008032f0&gt;&gt;")*/从结构上看@interface UIStackView : UIView，UIStackView是继承自UIView，对比下他们的关系：  subviews：它的顺序实际上是图层覆盖顺序，也就是视图元素的z轴。  arrangedSubviews：它的顺序代表了 stack 堆叠的位置顺序，即视图元素的x轴和y轴。  如果一个元素没有被 addSubview，调用 arrangedSubviews 会自动 addSubview。  当一个元素被 removeFromSuperview ，则 arrangedSubviews也会同步移除。  当一个元素被 removeArrangedSubview， 不会触发 removeFromSuperview，它依然在视图结构中。布局可以控制布局的几种方式，@property(nonatomic) UILayoutConstraintAxis axis;@property(nonatomic) UIStackViewDistribution distribution;@property(nonatomic) UIStackViewAlignment alignment;@property(nonatomic) CGFloat spacing;@property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement;@property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement;axis 布局方向（轴）@property(nonatomic) UILayoutConstraintAxis axis;typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) {    UILayoutConstraintAxisHorizontal = 0, // 水平方向    UILayoutConstraintAxisVertical = 1 // 垂直方向};distribution 子视图的分布@property(nonatomic) UIStackViewDistribution distribution;typedef NS_ENUM(NSInteger, UIStackViewDistribution) {    UIStackViewDistributionFill = 0,// 默认，轴方向上填充    UIStackViewDistributionFillEqually, //轴方向等宽或登高    UIStackViewDistributionFillProportionally,// 轴方向，比例分布    UIStackViewDistributionEqualSpacing,// 子视图间隔一致    UIStackViewDistributionEqualCentering, // 子视图中心距离一致}UIStackViewDistributionFill  UILayoutConstraintAxisHorizontal:          UIStackView中的所有子视图的宽度等于UIStackView的宽。      当UIStackView中有1个子视图，则子视图的宽度就等于UIStackView的宽。      当UIStackView中有2个子视图，且优先级一样，则会拉伸或压缩某个子视图，使两个子视图的宽度之和等于UIStackView的宽。      当UIStackView中有2个子视图，且优先级不一样，则会按优先级从高到低设置子视图的位置，对优先级最低的子视图进行必要的拉伸或压缩。        UILayoutConstraintAxisVertical:          UIStackView中的所有子视图的宽度等于UIStackView的高。      当UIStackView中有1个子视图，则子视图的高度就等于UIStackView的高。      当UIStackView中有2个子视图，且优先级一样，则会拉伸或压缩某个子视图，使两个子视图的高度之和等于UIStackView的高。      当UIStackView中有2个子视图，且优先级不一样，则会按优先级从高到低设置子视图的位置，对优先级最低的子视图进行必要的拉伸或压缩。      UIStackViewDistributionFill基本就是在轴方向上对子视图进行填充，类似对所有的子视图执行了下面两个方法：// 别挤我- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;// 抱紧，类似于sizefit，不会根据父view长度变化- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;UIStackViewDistributionFillEqually  UILayoutConstraintAxisHorizontal:          所有子视图在轴方向上等宽。        UILayoutConstraintAxisVertical:          所有子视图在轴方向上等高。      [subView1 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow();}];[subView2 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow();}];[subView3 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow();}];[stackView makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view);    make.top.equalTo(@100);    make.right.lessThanOrEqualTo(self.view);    make.height.equalTo(@200);}];UIStackViewDistributionFillProportionally该属性设置后会根据原先子视图的比例来拉伸或压缩子视图的宽或高，如果三个子视图原先设置的宽度是1：2：3，所以水平方向上显示时，会按照这个比例进行拉伸。[subView1 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(1, 200))).priorityLow();}];[subView2 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(2, 200))).priorityLow();}];[subView3 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(3, 200))).priorityLow();}];[stackView makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view);    make.top.equalTo(@100);    make.right.equalTo(self.view);    make.height.equalTo(@200);}];UIStackViewDistributionEqualSpacing该属性会保持子视图的宽高，所有子视图中间的间隔保持一致。[subView1 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow();}];[subView2 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow();}];[subView3 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow();}];[stackView makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view);    make.top.equalTo(@100);    make.right.lessThanOrEqualTo(self.view);    make.height.equalTo(@200);}];- (void)viewDidLoad {    [super viewDidLoad];    self.view.backgroundColor = [UIColor whiteColor];        UIView *subView1 = [LayoutUtils createView];    UIView *subView2 = [LayoutUtils createView];    UIView *subView3 = [LayoutUtils createView];        subView1.tag = 0;    subView2.tag = 1;    subView3.tag = 2;        subView1.backgroundColor = UIColor.redColor;    subView2.backgroundColor = UIColor.greenColor;    subView3.backgroundColor = UIColor.blueColor;        [subView1 makeConstraints:^(MASConstraintMaker *make) {        make.size.equalTo(@(CGSizeMake(130, 100)));    }];    [subView2 makeConstraints:^(MASConstraintMaker *make) {        make.size.equalTo(@(CGSizeMake(130, 80)));    }];    [subView3 makeConstraints:^(MASConstraintMaker *make) {    	// priorityLow() 是为了防止子视图总宽度超过，UIStackView 限制的宽度被挤压而产生的约束不合法。        make.size.equalTo(@(CGSizeMake(130, 120))).priorityLow();    }];    // 130 * 3 = 390 &gt; 375 ，超过屏幕的宽度了，subView3 优先级比较低，所以首先会被挤压。        sv = [[UIStackView alloc] initWithArrangedSubviews:@[subView1,subView2,subView3]];    sv.alignment = UIStackViewAlignmentBottom;    sv.distribution = UIStackViewDistributionEqualSpacing;    sv.spacing = 30;    [self.view addSubview:sv];    // 不设置宽度，让它宽度自适应    [sv makeConstraints:^(MASConstraintMaker *make) {        make.left.equalTo(kPadding);        make.top.equalTo(@100);        make.right.lessThanOrEqualTo(kPadding);        make.height.equalTo(200);    }];}-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{    for (UIView *object in sv.arrangedSubviews) {        if (object.tag == 1) {            [object setHidden:YES]; // [object removeFromSuperview];        }    }}UIStackViewDistributionEqualCentering该属性会控制所有子视图的中心之间的距离保持一致。[subView1 makeConstraints:^(MASConstraintMaker *make) {     make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow();}];[subView2 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow();}];[subView3 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow();}];[stackView makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view);    make.top.equalTo(@100);    make.right.equalTo(self.view);    make.height.equalTo(@200);}];alignmentalignment : 控制子视图之间的间隔大小。在distribution属性设置为UIStackViewDistributionFill、UIStackViewDistributionFillEqually、UIStackViewDistributionFillProportionally值的时候，子视图是没有间隔的，我们就可以通过alignment属性来设置子视图之间的间距。@property(nonatomic) UIStackViewAlignment alignment;typedef NS_ENUM(NSInteger, UIStackViewAlignment) {    UIStackViewAlignmentFill,    UIStackViewAlignmentLeading,    UIStackViewAlignmentTop = UIStackViewAlignmentLeading,    UIStackViewAlignmentFirstBaseline,     UIStackViewAlignmentCenter,    UIStackViewAlignmentTrailing,    UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing,    UIStackViewAlignmentLastBaseline, }UIStackViewAlignmentFill尽可能铺满UIStackViewAlignmentLeading、UIStackViewAlignmentTop  UILayoutConstraintAxisVertical :          UIStackViewAlignmentLeading 按 leading 方向对齐        UILayoutConstraintAxisHorizontal :          UIStackViewAlignmentTop 按 top 方向对齐。      [subView1 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow();}];[subView2 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow();}];[subView3 makeConstraints:^(MASConstraintMaker *make) {    make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow();}];[stackView makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view);    make.top.equalTo(@100);    make.right.equalTo(self.view);    make.height.equalTo(@200);}];UIStackViewAlignmentTrailing、UIStackViewAlignmentBottom  UILayoutConstraintAxisVertical :          UIStackViewAlignmentTrailing 按 trailing 方向对齐。        UILayoutConstraintAxisHorizontal :          UIStackViewAlignmentBottom 按 bottom 方向对齐。      UIStackViewAlignmentCenter居中对齐UIStackViewAlignmentFirstBaseline  UILayoutConstraintAxisVertical : 垂直方向无效。  UILayoutConstraintAxisHorizontal : 水平方向有效，按首行基线对齐。UIStackViewAlignmentLastBaseline  UILayoutConstraintAxisVertical : 垂直方向无效。  UILayoutConstraintAxisHorizontal : 水平方向有效，按文章底部基线对齐。spacing// 设置元素之间的边距值@property(nonatomic) CGFloat spacing;baselineRelativeArrangement// 决定了垂直轴如果是文本的话，是否按照 baseline 来参与布局，默认 false。@property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement;layoutMarginsRelativeArrangement// 如果打开则通过 layout margins 布局，关闭则通过 bounds，默认 false。@property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement;刷新布局UIView *subView = [LayoutUtils createView];[self.topStackView addArrangedSubview:subView];[UIView animateWithDuration:0.25 animations:^{    [self.topStackView layoutIfNeeded];}];子视图操作// 新增- (void)addArrangedSubview:(UIView *)view;// 移除- (void)removeArrangedSubview:(UIView *)view;// 插入- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex;示例点赞NSMutableArray&lt;UIView*&gt; *imageViewArray = [NSMutableArray array];for (int i = 0; i &lt; 5; i ++) {    UIView *subView = [LayoutUtils createView];    [subView makeConstraints:^(MASConstraintMaker *make) {        make.size.equalTo(@(CGSizeMake(50, 50)));    }];    subView.layer.cornerRadius = 25;    subView.layer.masksToBounds = YES;    subView.clipsToBounds = true;    [imageViewArray addObject:subView];}UIStackView *stackView = [[UIStackView alloc] initWithArrangedSubviews:imageViewArray];stackView.distribution = UIStackViewDistributionFillEqually;stackView.alignment = UIStackViewAlignmentCenter;stackView.spacing = -15;[self.view addSubview:stackView];[stackView makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.view);    make.top.equalTo(@100);    //make.right.equalTo(self.view);    make.height.equalTo(@50);}];给人打星评价@interface UIKitExampleStackViewStarController ()@property(nonatomic,strong) UIStackView *topStackView;@property(nonatomic,strong) UIStackView *bottomStackView;@end@implementation UIKitExampleStackViewStarController- (instancetype)init{    self = [super init];    if (self) {        self.title = @"点击星星";        self.view.backgroundColor = [UIColor whiteColor];    }    return self;}- (void)viewDidLoad {    [super viewDidLoad];    _topStackView = [[UIStackView alloc] init];    _topStackView.axis = UILayoutConstraintAxisVertical;    _topStackView.alignment = UIStackViewAlignmentCenter;    _topStackView.distribution = UIStackViewDistributionFillEqually;    _topStackView.spacing = 6;        _bottomStackView = [[UIStackView alloc] init];    _bottomStackView.alignment = UIStackViewAlignmentCenter;    _bottomStackView.distribution = UIStackViewDistributionFillEqually;    _bottomStackView.spacing = 6;        [self.view addSubview:self.topStackView];    [self.view addSubview:self.bottomStackView];        [self.topStackView makeConstraints:^(MASConstraintMaker *make) {        make.left.right.equalTo(self.view);        make.top.equalTo(@100);        make.height.equalTo(400);    }];        [self.bottomStackView makeConstraints:^(MASConstraintMaker *make) {        make.bottom.equalTo(self.view);        make.centerX.equalTo(self.view);        make.top.equalTo(self.topStackView.mas_bottom);    }];        UILabel *titleLabel = [LayoutUtils fixedLabelWithText:@"给个评价吧？"];    UIView *logoView = [LayoutUtils createView];    UIButton *addStarButton = [LayoutUtils createButtonWithTitle:@"Star" target:self selector:@selector(addStar)];    UIButton *removeStarButton = [LayoutUtils createButtonWithTitle:@"Remove Star" target:self selector:@selector(removeStar)];    UIStackView *operation = [[UIStackView alloc] initWithArrangedSubviews:@[addStarButton,removeStarButton]];    operation.distribution = UIStackViewDistributionFillEqually;        [self.topStackView addArrangedSubview:titleLabel];    [self.topStackView addArrangedSubview:logoView];    [self.topStackView addArrangedSubview:operation];        [logoView makeConstraints:^(MASConstraintMaker *make) {        make.size.equalTo(@(CGSizeMake(50, 50))).priorityLow();    }];        [self.topStackView layoutIfNeeded];}-(void)addStar{    UIView *starView = [LayoutUtils createView];    [self.bottomStackView addArrangedSubview:starView];    [starView makeConstraints:^(MASConstraintMaker *make) {        make.size.equalTo(@(CGSizeMake(50, 50))).priorityHigh();    }];    starView.layer.cornerRadius = 25;    starView.layer.masksToBounds = YES;    starView.clipsToBounds = true;    [UIView animateWithDuration:0.2 animations:^{        [self.bottomStackView layoutIfNeeded];    }];}-(void)removeStar{    if (self.bottomStackView.arrangedSubviews.count &gt;= 1) {        [self.bottomStackView.arrangedSubviews.lastObject removeFromSuperview];        [UIView animateWithDuration:0.2 animations:^{            [self.bottomStackView layoutIfNeeded];        }];    }}@end添加边距stackView.layoutMargins = UIEdgeInsetsMake(0, 10, 0, 10);[stackView setLayoutMarginsRelativeArrangement:YES];翻译资料  掘金-UIStackView 入坑指南  iOS 9: Getting Started with UIStackView]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS开发随笔(一)]]></title>
      <url>/ios/2020/06/11/ios-notes/</url>
      <content type="text"><![CDATA[// NS_REQUIRES_SUPER:子类方法必须调用[super updateConstraints]- (void)updateConstraints API_AVAILABLE(ios(6.0)) NS_REQUIRES_SUPER;// 拆分以 , 分隔的字符串。【a,b,c -&gt; [a,b,c]】、 【a,b,c, -&gt; [a,b,c]】、【a -&gt; [a]】if (self.cellData.imgs &amp;&amp; self.cellData.imgs.length &gt; 0) {    NSString *temptString = self.cellData.imgs;    if ([[temptString substringFromIndex:temptString.length-1] isEqualToString:@","]) {        temptString = [temptString substringToIndex:[temptString length]-1];    }    self.imagesArr = [temptString componentsSeparatedByString:@","];}// double ceil (double); 向上取整ceil(10.1); // 11ceil(10.9); // 11// double floor (double); 向下取整floor(10.1); // 10floor(10.9); // 10// double fabs (double);绝对值fabs(-10); // 10// 将参数的整数部分通过指针回传, 返回小数部分// float modff(float, float *);// double modf(double, double *);// long double modfl(long double, long double *);double integerValue; // 3double remainderValue = modf(3.1415926, &amp;integerValue); // 0.14159260000000007NSLog(@"inter:%.0f,remainder:%.2f",integerValue,remainderValue);//inter:3,remainder:0.14// double fmod (double, double); 返回两参数相除的余数fmod(10, 3) // 1// double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度// 四舍五入取整// extern float nearbyintf(float);// extern double nearbyint(double);// extern long double nearbyintl(long double);nearbyintf(9.0110); // 9nearbyintf(9.599); // 10// 返回x和y中大的数字// extern float fmaxf(float, float);// extern double fmax(double, double);// 返回x和y中小的数字// extern float fminf(float, float);// extern double fmin(double, double);// extern long double fminl(long double, long double);//iOS输出数值控制位数[NSString stringWithFormat:@"%.2f",5.212212]; // 5.21[NSString stringWithFormat:@"%02d",2]; // 002]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[protocol]]></title>
      <url>/ios/2020/06/08/ios-protocol/</url>
      <content type="text"><![CDATA[示例UITableViewDataSource非常简单的例子说明，@protocol UITableViewDataSource，在iOS中的协议(protocol)，可看成JAVA中的接口(interface),在UITableView中：@property (nonatomic, weak, nullable) id &lt;UITableViewDataSource&gt; dataSource;可以看出属性dataSource中，你只要赋值一个遵守&lt;UITableViewDataSource&gt;协议的对象就行，也就是JAVA中的Impl。@interface TableViewDataSourceImpl : NSObject&lt;UITableViewDataSource&gt;@property (nonatomic,strong) NSArray *array;@end@implementation TableViewDataSourceImpl- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {    return _array.count;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {    CustomTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"Cell"];    if (cell == nil) {        cell = [[CustomTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"Cell"];    }    cell.titleLabel.text=((CustomModel *)[_array objectAtIndex:indexPath.row]).title;    return cell;}@end// ==使用- (void)viewDidLoad {    tableViewDataSource=[[TableViewDataSourceImpl alloc] init];    tableView.dataSource=tableViewDataSource;}]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git]]></title>
      <url>/diary/2020/06/08/diary-git/</url>
      <content type="text"><![CDATA[branchlog$ git log --author="yeatse" --format="%cd : %s" --since=last.Monday --reverse --no-merges --date=format:'%F %T'# ==============# 2016-02-29 22:04:54 : Update elctron-prebuilt version. Fix #11.# 2016-02-29 22:49:51 : Optimize user's avatar display in Linux.# 2016-02-29 23:03:20 : Disable zooming in the app.# 2016-03-01 00:23:32 : Introduce travis CI.# 2016-03-01 00:28:14 : Fix tar-all chmod.项目管理查看当前项目的git的服务器地址git remote -v查看本地修改的文件$ git diffdiff --git a/LICENSE b/LICENSEindex 49dcc0c..698116f 100644--- a/LICENSE+++ b/LICENSE@@ -19,3 +19,4 @@ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.+localdiff --git a/ss_intellij_example/LICENSE.txt b/ss_intellij_example/LICENSE.txtindex 49dcc0c..9500224 100644--- a/ss_intellij_example/LICENSE.txt+++ b/ss_intellij_example/LICENSE.txt@@ -18,4 +18,4 @@ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE-SOFTWARE.+local-ss_intellij_example\ No newline at end of file上传代码# 更新远程仓库git pull# 将项目的所有文件添加到缓存中git add . # 将文件提交到本地仓库git commit -m "message"# 上传到远程仓库git push本地项目关联到远程git仓库完全空白项目关联#git初始化git init#设置remote地址git remote add origin 地址#将全部文件加入git版本管理 .的意思是将当前文件夹下的全部文件放到版本管理中git add .#提交文件 使用-m 编写注释git commit -m "注释"#推送到远程分支git push有文件的项目关联#git初始化git init#设置remote地址git remote add  origin 地址#获取远程仓库master分支上的内容git pull origin master#将当前分支设置为远程仓库的master分支git branch --set-upstream-to=origin/master master#将全部文件加入git版本管理 .的意思是将当前文件夹下的全部文件放到版本管理中git add .#提交文件 使用-m 编写注释git commit -m "注释"#推送到远程分支git push拉取代码拉取指定branch的代码git clone -b repo_url拉取指定commit的代码cd local_repogit checkout commit_SHA拉取指定tag的代码# 查看本地taggit taggit checkout tag_name强制更新git fetch --allgit reset --hard origin/master # origin/master 是主干，可以改成指定分支的名称git pull分支管理查看远程分支# 更新远程仓库git pull# 查看本地分支git branch# 查看远程分支git branch -r# 查看所有分支git branch -a创建并提交分支# 创建分支git branch branch_name# 切换到创建的分支git checkout branch_name# 上面两句可以直接通过下面一句实现,-b表示创建并切换git checkout -b branch_name# 查看当前分支,当前分支前面会标一个*号git branch# 把修改的文件上传git add .git commit -m "branch test"git push --set-upstream origin branch_name# 切回master分支git checkout master切分支# 查看当前分支,当前分git branch支前面会标一个*号git branch# 切回branch_name分支git checkout branch_name重命名本地分支git branch -m old_branch new_branch # Rename branch locally git push origin :old_branch # Delete the old branch git push --set-upstream origin new_branch # Push the new branch, set local branch to track 同步远程已删除的分支$ git remote show origin* remote origin  Fetch URL: https://gitee.com/BackEndLearning/spring_security_tec.git  Push  URL: https://gitee.com/BackEndLearning/spring_security_tec.git  HEAD branch: master  Remote branches:    dev1                   new (next fetch will store in remotes/origin)    dev3                   new (next fetch will store in remotes/origin)    master                 tracked    refs/remotes/origin/d2 stale (use 'git remote prune' to remove)  Local branch configured for 'git pull':    master merges with remote master  Local ref configured for 'git push':    master pushes to master (up to date)# 从打印的日志中可以看出，远程仓库d2分制被删除。运行命令同步远程仓库$ git remote prune origin# 查看处理结果$ git branch -a删除本地仓库中的分支# 删除本地多余分支git branch -D branch_name直接删除远程仓库中的分支# 更新远程库git pull# 查看所有远程库分支git branch -r# 删除分支&amp;更新远程库git push origin --delete branch_name拉取所有分支git pull -a标签管理创建tag# 显示所有taggit tag# 创建taggit tag -a v1.0.0 -m "tag log"查看tag信息# 更新仓库git pull# 显示所有taggit tag# 显示所有tag的版本号和描述信息git tag -l -n# 查看指定tag详细信息git show tag_name后期打tag$ git log --pretty=oneline1214241a0f16bd3a256fe9153b2af86122550cbf (HEAD -&gt; master, tag: v1.0.0, origin/dev) a6a09733d4be9fc62447cace7f131ceb05bdee15d (origin/master) add docs8d57db34e110b4e97082eb3a610cc1b356067d7e teste056aa245180d1eee2c08633712bfd393e2d0e92 testd673babfddb2987364153cbfbcd912080fd72f8e Initial commit# 给e056aa245180d1eee2c08633712bfd393e2d0e92节点的commit打标签$ git tag -a v1.0.2 e056aa245180d1eee2c08633712bfd393e2d0e92 -m "git log"上传tag# 上传所有tagsgit push origin --tags# 上传单个taggit push origin v1.0.2删除tag# 显示所有taggit tag# 删除指定taggit tag -d v1.0.2# 更新远程repogit push origin :refs/tags/v1.0.2检出tag# 查看所有taggit tag# 检出git checkout tag_name提交日志规范commit日志# 多行日志git commit -m 'line_1line_2'# 单行日志git commit -m "log"提交type  feature : 功能添加。  bugfix : 修复bug。  docs : 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等。  style : 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑。  refactor : 代码重构，没有加新功能或者修复bug。  perf : 优化相关，比如提升性能、体验。  test : 测试用例，包括单元测试、集成测试等。  chore : 改变构建流程、或者增加依赖库、工具等。  revert : 回滚到上一个版本。参考资料  廖雪峰的官方网站  git 官方说明文档]]></content>
      <categories>
        
          <category> diary </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Objective-C 开发规范]]></title>
      <url>/ios/2020/05/29/ios-dev-standard/</url>
      <content type="text"><![CDATA[编程规约注释规约  【强制】  【推荐】 善于使用标记代码标记。//MARK: &lt;#Write here#&gt;//TODO: &lt;#Write here#&gt;//FIXME: &lt;#Write here#&gt;//!!!!: &lt;#Write here#&gt;//???: &lt;#Write here#&gt;  【参考】UITableView@interface DouBanDetailTableViewCell()@end@implementation DouBanDetailTableViewCell+(NSString*)reuseIdentifier{    return NSStringFromClass([self class]);}+(DouBanDetailTableViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{    DouBanDetailTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[DouBanDetailTableViewCell reuseIdentifier]];    if (!cell) {        cell = [[DouBanDetailTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[DouBanDetailTableViewCell reuseIdentifier]];    }    cell.indexPath = indexPath;    return cell;}-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        [self cellAddSubViews];    }    return self;}#pragma mark - init Views-(void)cellAddSubViews{}#pragma mark - Layout-(void)updateConstraints{    [super updateConstraints];}#pragma mark - getter@end]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Omnigraffle 使用记录]]></title>
      <url>/diary/2020/05/29/diary-omnigraffle/</url>
      <content type="text"><![CDATA[  绘制垂直或水平直线:首先按住键盘中的Shift键，而后鼠标左键单击，拖动鼠标开始绘制。  cmd+D:复制图层。]]></content>
      <categories>
        
          <category> diary </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ReactiveCocoa]]></title>
      <url>/ios/2020/05/28/ios-reactivecocoa/</url>
      <content type="text"><![CDATA[代码的仓库基础RACSignal 触发流程下面代码是RACSignal创建和被订阅的演示。-(void)test_sig_1{    //Create a Signal.    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        for (NSInteger i = 0; i &lt;= 5; i++) {            [subscriber sendNext:@(i)];        }        [subscriber sendCompleted];        return [RACDisposable disposableWithBlock:^{            NSLog(@"RACDisposable block");        }];    }];    // Subscribe a Signal    // English: disposable: adj.可任意处理的；可自由使用的；用完即可丢弃的    RACDisposable * disposable = [signal subscribeNext:^(id  _Nullable x) {        NSLog(@"Recive signal:%@",x);    } error:^(NSError * _Nullable error) {        NSLog(@"Recive signal:%@",error.localizedDescription);    } completed:^{        NSLog(@"completed!");    }] ;        // Release the Subscriber    [disposable dispose];}RACSignal底层实现:  创建信号，首先把didSubscribe保存到信号中，还不会触发。  当信号被订阅(调用signal的subscribeNext:nextBlock)时：          subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中      subscribeNext内部会调用siganl的didSubscribe      当信号订阅完成, 不在发送数据的时候, 最好调用完成发送的[subscriber sendCompleted]      订阅完成的时候, 内部会自动调用[RACDisposable disposable]取消订阅信号        当siganl的didSubscribe中调用[subscriber sendNext:@1]时，sendNext底层其实就是执行subscriber的nextBlockRACSignal的一些子类及作用：//  `RACDynamicSignal`(动态信号) 是`RACSignal`的子类,使用一个`block`来实现订阅行为。@interface RACDynamicSignal : RACSignal// block 中 id&lt;RACSubscriber&gt; subscriber+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe;@end// 一元信号，用来实现 RACSignal 的 +return:方法@interface RACReturnSignal&lt;__covariant ValueType&gt; : RACSignal&lt;ValueType&gt;+ (RACSignal&lt;ValueType&gt; *)return:(ValueType)value;@end// 错误信号，用来实现 RACSignal 的 +error: 方法@interface RACErrorSignal : RACSignal+ (RACSignal *)error:(NSError *)error;@end// 通道终端，代表 RACChannel 的一个终端，用来实现双向绑定@interface RACChannelTerminal&lt;ValueType&gt; : RACSignal&lt;ValueType&gt; &lt;RACSubscriber&gt;- (instancetype)init __attribute__((unavailable("Instantiate a RACChannel instead")));- (void)sendNext:(nullable ValueType)value;@end// 信号提供者，自己可以充当信号，又能发送信号@interface RACSubject&lt;ValueType&gt; : RACSignal&lt;ValueType&gt; &lt;RACSubscriber&gt;+ (instancetype)subject;- (void)sendNext:(nullable ValueType)value;@endRACSubscriber 订阅者协议的内容：@protocol RACSubscriber &lt;NSObject&gt;- (void)sendNext:(nullable id)value;- (void)sendError:(nullable NSError *)error;- (void)sendCompleted;- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;@endRACSubject、RACReplaySubjectRACSubject 信号提供者：  RACSubject(信号提供者)，自己可以充当信号，又能发送信号。  触发条件：先订阅, 再发送信号。  使用场景:通常用来代替代理/通知。RACReplaySubject 重复提供信号：  先发送信号，再订阅信号@interface TestViewModel : NSObject@property (strong, nonatomic) RACSignal *signal;@property (strong, nonatomic) RACReplaySubject *replaySubject;@property (strong, nonatomic) RACSubject *subject;@end@implementation TestViewModel-(RACReplaySubject *)replaySubject{    if (!_replaySubject) {        _replaySubject = [RACReplaySubject subject];    }    return _replaySubject;}-(RACSubject *)subject{    if (!_subject) {        _subject = [RACSubject subject];    }    return _subject;}@end@interface TestViewController ()@property (weak, nonatomic) IBOutlet UIButton *registerButton;@property (weak, nonatomic) IBOutlet UIButton *loginButton;@property (weak, nonatomic) IBOutlet UILabel *textLabel;@property (weak, nonatomic) IBOutlet UITextField *textField;@property (weak, nonatomic) IBOutlet UIButton *sendSingnalButton;@property (strong, nonatomic) TestViewModel *viewModel;@end@implementation TestViewController- (void)viewDidLoad {    [super viewDidLoad];    [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        NSLog(@"you clicked the login button!");        [self.viewModel.replaySubject subscribeNext:^(id  _Nullable x) {            NSLog(@"RACReplaySubject %@",x);        }];        [self.viewModel.subject subscribeNext:^(id  _Nullable x) {            NSLog(@"RACSubject %@",x);        }];    }];    [[self.registerButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        NSLog(@"you clicked the register button!");        [self.viewModel.replaySubject subscribeNext:^(id  _Nullable x) {            NSLog(@"RACReplaySubject %@",x);        }];        [self.viewModel.subject subscribeNext:^(id  _Nullable x) {            NSLog(@"RACSubject %@",x);        }];    }];    [[self.sendSingnalButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        [self.viewModel.subject sendNext:@2];        [self.viewModel.replaySubject sendNext:@2];    }];}-(TestViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [TestViewModel new];        [_viewModel.replaySubject sendNext:@1];        [_viewModel.subject sendNext:@1];    }    return _viewModel;}@end/*you clicked the login button!RACReplaySubject 1 ==&gt; RACReplaySubject 先发送了信号，然后再点击login方法进行订阅。这里没有 RACSubject 的打印信息，是因为 RACSubject 必须先订阅再发送信号。you clicked the register button!RACReplaySubject 1 ==&gt; RACReplaySubject 先发送了信号，然后再点击login方法进行订阅。这里没有 RACSubject 的打印信息，是因为 RACSubject 必须先订阅再发送信号。RACSubject 2RACSubject 2 ==&gt; login register 两个方法各订阅了一次信号，点击几次方法就会重复订阅RACReplaySubject 2 ==&gt; login register 两个方法各订阅了一次信号，点击几次方法就会重复订阅RACReplaySubject 2RACSubject 2RACSubject 2RACReplaySubject 2RACReplaySubject 2*/做一个RACSubject作为代理的简单示例：@interface TestViewModel : NSObject@property (strong, nonatomic) RACSubject *subject;-(void)loadData;@end@implementation TestViewModel-(void)loadData{    // request service data,return data to vc    [self.subject sendNext:@1];}-(RACSubject *)subject{    if (!_subject) {        _subject = [RACSubject subject];    }    return _subject;}@end@interface TestViewController ()@property (weak, nonatomic) IBOutlet UIButton *registerButton;@property (weak, nonatomic) IBOutlet UIButton *loginButton;@property (weak, nonatomic) IBOutlet UILabel *textLabel;@property (weak, nonatomic) IBOutlet UITextField *textField;@property (weak, nonatomic) IBOutlet UIButton *sendSingnalButton;@property (strong, nonatomic) TestViewModel *viewModel;@end@implementation TestViewController- (void)viewDidLoad {    [super viewDidLoad];    [self.viewModel.subject subscribeNext:^(id  _Nullable x) {        NSLog(@"Service data: %@",x);    }];    @weakify(self)    [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        @strongify(self)        NSLog(@"you clicked the login button!");        [self.viewModel loadData];    }];}-(TestViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [TestViewModel new];    }    return _viewModel;}@end冷信号与热信号热信号  热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。 例中：信号在 19:37:55 被创建，在 19:37:56 发出信号1，但是没有订阅，在 19:37:57发出信号2，这是有一个订阅。  热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。 例中：订阅者1和订阅者2都在 19:37:58 收到了数据。- (void)viewDidLoad {    [super viewDidLoad];        RACMulticastConnection * connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{            [subscriber sendNext:@1];        }];        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{            [subscriber sendNext:@2];        }];        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{            [subscriber sendNext:@3];        }];        [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{            [subscriber sendCompleted];        }];        return nil;    }]publish];    [connection connect];    RACSignal *signal = connection.signal;    NSLog(@"Signal was created.");        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [signal subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 1 recveive: %@", x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@"Subscriber 2 recveive: %@", x);        }];    }];}/*2020-05-28 19:37:55.689906+0800 RACExample[56065:11840136] Signal was created. 2020-05-28 19:37:57.690140+0800 RACExample[56065:11840136] Subscriber 1 recveive: 22020-05-28 19:37:58.690022+0800 RACExample[56065:11840136] Subscriber 1 recveive: 32020-05-28 19:37:58.690210+0800 RACExample[56065:11840136] Subscriber 2 recveive: 3*/冷信号  冷信号是被动的，只有当你订阅的时候，它才会发送消息。  冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。 例中：两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。- (void)viewDidLoad {    [super viewDidLoad];        RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{            [subscriber sendNext:@1];        }];        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{            [subscriber sendNext:@2];        }];        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{            [subscriber sendNext:@3];        }];        [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{            [subscriber sendCompleted];        }];        return nil;    }];    NSLog(@"Signal was created.");        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [signal subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 1 recveive: %@", x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@"Subscriber 2 recveive: %@", x);        }];    }];}/*2020-05-28 19:42:38.439542+0800 RACExample[56245:11843585] Signal was created.2020-05-28 19:42:40.540420+0800 RACExample[56245:11843585] Subscriber 1 recveive: 12020-05-28 19:42:41.537044+0800 RACExample[56245:11843585] Subscriber 1 recveive: 22020-05-28 19:42:41.849789+0800 RACExample[56245:11843585] Subscriber 2 recveive: 12020-05-28 19:42:42.669102+0800 RACExample[56245:11843585] Subscriber 1 recveive: 32020-05-28 19:42:42.884800+0800 RACExample[56245:11843585] Subscriber 2 recveive: 22020-05-28 19:42:43.841321+0800 RACExample[56245:11843585] Subscriber 2 recveive: 3*/冷信号、热信号比较// 冷信号代码-(void)test_Signal{    // Create an RACReplaySubject signals    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        // Send Signals        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{            [subscriber sendNext:@"replaySubject send package 1"];        }];        // Send Signals        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{            [subscriber sendNext:@"replaySubject send package 2"];        }];        return [RACDisposable disposableWithBlock:^{            NSLog(@"disposable");        }];    }];    NSLog(@"create Signal");        // Subscribe the signal    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{        //Subscriber1        [signal subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 1 get a next value: %@ from replay subject", x);        }];                //Subscriber2        [signal subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 2 get a next value: %@ from replay subject", x);        }];    }];        // Subscribe the signal    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{        //Subscriber3        [signal subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 3 get a next value: %@ from replay subject", x);        }];                //Subscriber4        [signal subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 4 get a next value: %@ from replay subject", x);        }];    }];}// Subject 热信号代码-(void)test_RACSubject{    // Create a RACSubject signal    RACSubject *subject = [RACSubject subject];    NSLog(@"create Signal");        // Subscribe the signal    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{        //Subscriber1        [subject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 1 get a next value: %@ from subject", x);        }];        //Subscriber2        [subject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 2 get a next value: %@ from subject", x);        }];    }];        // Send Signals    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [subject sendNext:@"subject send package 1"];    }];        // Subscribe the signal    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{        //Subscriber3        [subject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 3 get a next value: %@ from subject", x);        }];                //Subscriber4        [subject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 4 get a next value: %@ from subject", x);        }];           }];        // Send Signals    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{        [subject sendNext:@"subject send package 2"];    }];}// ReplaySubject 热信号代码-(void)test_RACReplaySubject{    // Create an RACReplaySubject signals    RACSubject *replaySubject = [RACReplaySubject subject];    NSLog(@"create Signal");        // Subscribe the signal    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{        //Subscriber1        [replaySubject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 1 get a next value: %@ from replay subject", x);        }];                //Subscriber2        [replaySubject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 2 get a next value: %@ from replay subject", x);        }];    }];        // Send Signals    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [replaySubject sendNext:@"replaySubject send package 1"];    }];        // Subscribe the signal    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{        //Subscriber3        [replaySubject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 3 get a next value: %@ from replay subject", x);        }];                //Subscriber4        [replaySubject subscribeNext:^(id  _Nullable x) {            NSLog(@"Subscriber 4 get a next value: %@ from replay subject", x);        }];    }];        // Send Signals    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{        [replaySubject sendNext:@"replaySubject send package 2"];    }];}RACSignal和热信号RACSubject时间比较：  RACSubject中，4个订阅者共享subject,在subject发送信号的时候，所有的订阅者都能收到信号数据；因为subscriber3、subscriber4订阅的时间稍后，错过了subject发送的信号数据。  对比发现: subject类似直播，错过了就不再处理。而signal类似点播，每次订阅都会从头开始。所以我们有理由认定subject天然就是热信号。冷信号RACSignal和热信号ReplayRACSubject时间比较：热信号RACSubject和热信号ReplayRACSubject时间比较：  ReplayRACSubject中，Subscriber 3与Subscriber 4在订阅后马上接收到了“历史值”。对于Subscriber 3和Subscriber 4来说，它们只关心“历史的值”而不关心“历史的时间线”。·热信号和冷信号类：基础使用RACMulticastConnectionRACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    NSLog(@"发送信号1");    [subscriber sendNext:@"1"];    return nil;}];[signal subscribeNext:^(id  _Nullable x) { NSLog(@"第一次订阅：%@",x);}];[signal subscribeNext:^(id  _Nullable x) { NSLog(@"第二次订阅：%@",x);}];/*2020-06-08 16:20:16.479977+0800 RACExample[46980:352112] 发送信号12020-06-08 16:20:16.480517+0800 RACExample[46980:352112] 第一次订阅：12020-06-08 16:20:16.480976+0800 RACExample[46980:352112] 发送信号12020-06-08 16:20:16.481336+0800 RACExample[46980:352112] 第二次订阅：1*/在信号signal被订阅2次以后，createSignal:block也被触发了2次。通过RACMulticastConnection可以解决信号被n次订阅后，block也会被触发n次的情况。RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    NSLog(@"发送信号1");    [subscriber sendNext:@"1"];    return nil;}];RACMulticastConnection *signalBconnect = [signal publish];[signalBconnect.signal subscribeNext:^(id  _Nullable x) { NSLog(@"第一次订阅：%@",x);}];[signalBconnect.signal subscribeNext:^(id  _Nullable x) { NSLog(@"第二次订阅：%@",x);}];[signalBconnect connect];/*2020-06-08 16:25:18.009553+0800 RACExample[47186:354797] 发送信号12020-06-08 16:25:18.009805+0800 RACExample[47186:354797] 第一次订阅：12020-06-08 16:25:18.009907+0800 RACExample[47186:354797] 第二次订阅：1*/也可以通过RACSignal热信号去解决，其实RACMulticastConnection就相当于把signal变成了热信号：RACSubject *subject = [RACSubject subject];[subject subscribeNext:^(id  _Nullable x) { NSLog(@"第一次订阅：%@",x);}];[subject subscribeNext:^(id  _Nullable x) { NSLog(@"第二次订阅：%@",x);}];NSLog(@"发送信号1");[subject sendNext:@"1"];/*2020-06-08 16:26:34.201680+0800 RACExample[47240:355739] 发送信号12020-06-08 16:26:34.202059+0800 RACExample[47240:355739] 第一次订阅：12020-06-08 16:26:34.202349+0800 RACExample[47240:355739] 第二次订阅：1*/线程操作  副作用：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。  deliverON：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，  subscribeOn：内容传递和副作用都会切换到指定线程中。  deliverOnMainThread：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"sendNext1:%@",[NSThread currentThread]);// sendNext1:&lt;NSThread: 0x600001f36300&gt;{number = 4, name = (null)}        [subscriber sendNext:@"1"];        return nil;    }] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext%@:%@",x,[NSThread currentThread]);//subscribeNext1:&lt;NSThread: 0x600001f36300&gt;{number = 4, name = (null)}    }];});// 发送消息、接收消息都是在异步线程。dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"sendNext1:%@",[NSThread currentThread]);// sendNext1:&lt;NSThread: 0x600003e40040&gt;{number = 4, name = (null)}        [subscriber sendNext:@"1"];        return nil;    }] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext%@:%@",x,[NSThread currentThread]);//subscribeNext1:&lt;NSThread: 0x600003e04980&gt;{number = 1, name = main}    }];});// 接收消息在主线程。dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"sendNext1:%@",[NSThread currentThread]);// sendNext1:&lt;NSThread: 0x6000035fcbc0&gt;{number = 1, name = main}        [subscriber sendNext:@"1"];        return nil;    }] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext%@:%@",x,[NSThread currentThread]);//subscribeNext1:&lt;NSThread: 0x6000035fcbc0&gt;{number = 1, name = main}    }];});// 发送消息、接收消息都是在主线程。信号节流:throttle  throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    NSLog(@"11");[subscriber sendNext:@"发送消息11"];    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{        NSLog(@"21");[subscriber sendNext:@"发送消息21"];        NSLog(@"22");[subscriber sendNext:@"发送消息22"];    });    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{        NSLog(@"31");[subscriber sendNext:@"发送消息31"];        NSLog(@"32");[subscriber sendNext:@"发送消息32"];        NSLog(@"33");[subscriber sendNext:@"发送消息33"];    });    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{        NSLog(@"41");[subscriber sendNext:@"发送消息41"];        NSLog(@"42");[subscriber sendNext:@"发送消息42"];        NSLog(@"43");[subscriber sendNext:@"发送消息43"];        NSLog(@"44");[subscriber sendNext:@"发送消息44"];    });    return nil;}] throttle:2] subscribeNext:^(id  _Nullable x) {    NSLog(@"Next:%@",x);}];/*2020-06-08 19:09:37.356497+0800 RACExample[54681:455884] 112020-06-08 19:09:39.357101+0800 RACExample[54681:455884] Next:发送消息112020-06-08 19:09:39.357366+0800 RACExample[54681:455884] 212020-06-08 19:09:39.357518+0800 RACExample[54681:455884] 222020-06-08 19:09:40.540307+0800 RACExample[54681:455884] 312020-06-08 19:09:40.541107+0800 RACExample[54681:455884] 322020-06-08 19:09:40.541341+0800 RACExample[54681:455884] 332020-06-08 19:09:41.357386+0800 RACExample[54681:455884] 412020-06-08 19:09:41.357600+0800 RACExample[54681:455884] 422020-06-08 19:09:41.357734+0800 RACExample[54681:455884] 432020-06-08 19:09:41.357856+0800 RACExample[54681:455884] 442020-06-08 19:09:43.369260+0800 RACExample[54681:455884] Next:发送消息44*/信号错误重试:retry  retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.static int signalANum = 0;RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    if (signalANum &gt;= 5) {        NSLog(@"sendNext %d",signalANum);        [subscriber sendNext:[NSString stringWithFormat:@"尝试次数累计：%d",signalANum]];        [subscriber sendCompleted];    }else{        NSLog(@"sendError %d",signalANum);        [subscriber sendError:[NSError errorWithDomain:@"" code:0 userInfo:@{NSLocalizedDescriptionKey:@"Something is wrong!"}]];    }    signalANum++;    return nil;}];[[signal retry] subscribeNext:^(id  _Nullable x) {    NSLog(@"subscribeNext：%@",x);} error:^(NSError * _Nullable error) {    NSLog(@"error info: %@",error.localizedDescription);}];/*2020-06-08 19:03:16.750255+0800 RACExample[54389:451981] sendError 02020-06-08 19:03:16.774608+0800 RACExample[54389:451981] sendError 12020-06-08 19:03:16.774899+0800 RACExample[54389:451981] sendError 22020-06-08 19:03:16.775074+0800 RACExample[54389:451981] sendError 32020-06-08 19:03:16.775254+0800 RACExample[54389:451981] sendError 42020-06-08 19:03:16.775446+0800 RACExample[54389:451981] sendNext 52020-06-08 19:03:16.775579+0800 RACExample[54389:451981] subscribeNext：尝试次数累计：5*/获取信号中的信号: switchToLatest  switchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。  switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。信号发送顺序:doNext、doCompleted  发送信号前与发送信号后操作：doNext、doCompleted。  doNext：在订阅者发送消息sendNext之前执行。  doCompleted：在订阅者发送完成sendCompleted之后执行。RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    NSLog(@"发送信号：1");    [subscriber sendNext:@"发送信号：1"];    [subscriber sendCompleted];    return nil;}];[[[signal doNext:^(id  _Nullable x) {    NSLog(@"doNext,%@",x);}] doCompleted:^{    NSLog(@"doCompleted");}] subscribeNext:^(id  _Nullable x) {    NSLog(@"激活信号：%@",x);}];/*2020-06-08 18:49:53.413848+0800 RACExample[53730:443023] 发送信号：12020-06-08 18:49:53.414098+0800 RACExample[53730:443023] doNext,发送信号：12020-06-08 18:49:53.414220+0800 RACExample[53730:443023] 激活信号：发送信号：12020-06-08 18:49:53.414823+0800 RACExample[53730:443023] doCompleted*/信号取值:take、takeUntil、takeLast  take:从开始一共取N次的信号  takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.  takeUntil:(RACSignal):获取信号直到某个信号执行完成(原始信号一直发送信号，直到，替代的信号发出事件，原始信号终止)。  skip:(NSUInteger):跳过几个信号,不接受。-(RACSignal*)createSignal{    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        for (int i = 0; i &lt; 5; i++) {            NSLog(@"subscriber sendNext -- %d", i);            [subscriber sendNext:@(i)];        }        NSLog(@"sendCompleted");        [subscriber sendCompleted];                return nil;    }];}-(void)test_take{    RACSignal *signal = [self createSignal];   [signal subscribeNext:^(id  _Nullable x) {       NSLog(@"subscribeNext -- %@", x);   }];    /*     2020-06-03 14:51:53.558366+0800 RACExample[30888:2260368] subscriber sendNext -- 0     2020-06-03 14:51:53.558606+0800 RACExample[30888:2260368] subscribeNext -- 0     2020-06-03 14:51:53.558714+0800 RACExample[30888:2260368] subscriber sendNext -- 1     2020-06-03 14:51:53.558807+0800 RACExample[30888:2260368] subscribeNext -- 1     2020-06-03 14:51:53.558898+0800 RACExample[30888:2260368] subscriber sendNext -- 2     2020-06-03 14:51:53.558985+0800 RACExample[30888:2260368] subscribeNext -- 2     2020-06-03 14:51:53.559069+0800 RACExample[30888:2260368] subscriber sendNext -- 3     2020-06-03 14:51:53.559159+0800 RACExample[30888:2260368] subscribeNext -- 3     2020-06-03 14:51:53.559249+0800 RACExample[30888:2260368] subscriber sendNext -- 4     2020-06-03 14:51:53.559439+0800 RACExample[30888:2260368] subscribeNext -- 4     2020-06-03 14:51:53.559708+0800 RACExample[30888:2260368] sendCompleted     */上面是正常的订阅。-(void)test_take{    [[signal take:2] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext -- %@", x);    }];    /*     2020-06-03 14:53:40.530949+0800 RACExample[30990:2262219] subscriber sendNext -- 0     2020-06-03 14:53:40.531286+0800 RACExample[30990:2262219] subscribeNext -- 0     2020-06-03 14:53:40.531476+0800 RACExample[30990:2262219] subscriber sendNext -- 1     2020-06-03 14:53:40.531610+0800 RACExample[30990:2262219] subscribeNext -- 1     2020-06-03 14:53:40.531734+0800 RACExample[30990:2262219] subscriber sendNext -- 2     2020-06-03 14:53:40.531829+0800 RACExample[30990:2262219] subscriber sendNext -- 3     2020-06-03 14:53:40.531924+0800 RACExample[30990:2262219] subscriber sendNext -- 4     2020-06-03 14:53:40.532056+0800 RACExample[30990:2262219] sendCompleted     */}take:2 : 只取前两次订阅的信号。-(void)test_take{    [[[signal skip:1] take:1] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext -- %@", x);    }];    /*     2020-06-03 14:59:58.615703+0800 RACExample[31246:2265921] subscriber sendNext -- 0 ==&gt; 虽然发送的数据，但是 subscriber 没有使用，跳过这一条     2020-06-03 14:59:58.616069+0800 RACExample[31246:2265921] subscriber sendNext -- 1     2020-06-03 14:59:58.616254+0800 RACExample[31246:2265921] subscribeNext -- 1       ==&gt; take:1     2020-06-03 14:59:58.616376+0800 RACExample[31246:2265921] subscriber sendNext -- 2     2020-06-03 14:59:58.616494+0800 RACExample[31246:2265921] subscriber sendNext -- 3     2020-06-03 14:59:58.616608+0800 RACExample[31246:2265921] subscriber sendNext -- 4     */}skip:1和take:1 : 跳过第一条开始接收数据，并且只取前一条数据。-(void)test_takeLast{    [[signal takeLast:1] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext -- %@", x);    }];    /*     2020-06-03 15:04:32.363153+0800 RACExample[31419:2268388] signal -- 0     2020-06-03 15:04:32.363415+0800 RACExample[31419:2268388] signal -- 1     2020-06-03 15:04:32.363534+0800 RACExample[31419:2268388] signal -- 2     2020-06-03 15:04:32.363639+0800 RACExample[31419:2268388] signal -- 3     2020-06-03 15:04:32.363741+0800 RACExample[31419:2268388] signal -- 4     2020-06-03 15:04:32.363943+0800 RACExample[31419:2268388] subscribeNext -- 3     2020-06-03 15:04:32.364053+0800 RACExample[31419:2268388] subscribeNext -- 4     */}takeLast:1 : 只获取最新的数据。map、flattenMap(拦截信号处理数据)  map ：将信号内容修改为另一种新值。改变了传递的值。  flattenMap：将源信号映射修改为另一种新的信号(RACSignal),修改了信号本身。示例-(void)test_map{    RACSignal *syncSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {                for (int i = 0; i &lt; 5; i++) {            NSLog(@"signal -- %d", i);            [subscriber sendNext:@(i)];        }        [subscriber sendCompleted];                return nil;    }];        [[syncSignal map:^id _Nullable(id  _Nullable value) {        NSLog(@"map -- %@", value);        return [NSString stringWithFormat:@"MAP+%@",value];    }] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext -- %@", x);    }];}/*2019-08-30 14:00:05.098586+0800 RACExample[99686:2868124] signal -- 02019-08-30 14:00:05.098791+0800 RACExample[99686:2868124] map -- 02019-08-30 14:00:05.098987+0800 RACExample[99686:2868124] subscribeNext -- MAP+02019-08-30 14:00:05.099149+0800 RACExample[99686:2868124] signal -- 12019-08-30 14:00:05.099244+0800 RACExample[99686:2868124] map -- 12019-08-30 14:00:05.099370+0800 RACExample[99686:2868124] subscribeNext -- MAP+12019-08-30 14:00:05.099522+0800 RACExample[99686:2868124] signal -- 22019-08-30 14:00:05.099601+0800 RACExample[99686:2868124] map -- 22019-08-30 14:00:05.099717+0800 RACExample[99686:2868124] subscribeNext -- MAP+22019-08-30 14:00:05.099866+0800 RACExample[99686:2868124] signal -- 32019-08-30 14:00:05.100081+0800 RACExample[99686:2868124] map -- 32019-08-30 14:00:05.100398+0800 RACExample[99686:2868124] subscribeNext -- MAP+32019-08-30 14:00:05.100599+0800 RACExample[99686:2868124] signal -- 42019-08-30 14:00:05.100759+0800 RACExample[99686:2868124] map -- 42019-08-30 14:00:05.100999+0800 RACExample[99686:2868124] subscribeNext -- MAP+4*/flattenMap- (void)viewDidLoad {    [super viewDidLoad];        RACSignal *syncSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {                for (int i = 0; i &lt; 5; i++) {            NSLog(@"signal -- %d", i);            [subscriber sendNext:@(i)];        }        [subscriber sendCompleted];                return nil;    }];    [[syncSignal flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) {        NSLog(@"map -- %@", value);        return [RACSignal return:value].logCompleted;    }] subscribeNext:^(id  _Nullable x) {        NSLog(@"subscribeNext -- %@", x);    }];}/*2020-05-28 14:44:12.520009+0800 RACExample[45556:11658886] signal -- 02020-05-28 14:44:12.520142+0800 RACExample[45556:11658886] map -- 02020-05-28 14:44:12.520316+0800 RACExample[45556:11658886] subscribeNext -- 02020-05-28 14:44:12.520456+0800 RACExample[45556:11658886] &lt;RACReturnSignal: 0x60000023e320&gt; name:  completed2020-05-28 14:44:12.520567+0800 RACExample[45556:11658886] signal -- 12020-05-28 14:44:12.520658+0800 RACExample[45556:11658886] map -- 12020-05-28 14:44:12.520790+0800 RACExample[45556:11658886] subscribeNext -- 12020-05-28 14:44:12.520902+0800 RACExample[45556:11658886] &lt;RACReturnSignal: 0x60000023e360&gt; name:  completed2020-05-28 14:44:12.521116+0800 RACExample[45556:11658886] signal -- 22020-05-28 14:44:12.521573+0800 RACExample[45556:11658886] map -- 22020-05-28 14:44:12.521995+0800 RACExample[45556:11658886] subscribeNext -- 22020-05-28 14:44:12.522413+0800 RACExample[45556:11658886] &lt;RACReturnSignal: 0x600000238520&gt; name:  completed2020-05-28 14:44:12.522804+0800 RACExample[45556:11658886] signal -- 32020-05-28 14:44:12.537218+0800 RACExample[45556:11658886] map -- 32020-05-28 14:44:12.537473+0800 RACExample[45556:11658886] subscribeNext -- 32020-05-28 14:44:12.537624+0800 RACExample[45556:11658886] &lt;RACReturnSignal: 0x600000238560&gt; name:  completed2020-05-28 14:44:12.537738+0800 RACExample[45556:11658886] signal -- 42020-05-28 14:44:12.537825+0800 RACExample[45556:11658886] map -- 42020-05-28 14:44:12.537941+0800 RACExample[45556:11658886] subscribeNext -- 42020-05-28 14:44:12.538046+0800 RACExample[45556:11658886] &lt;RACReturnSignal: 0x600000238580&gt; name:  completed*/示例//创建一个普通信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    for (NSInteger i = 0; i &lt;= 5; i ++) {        [subscriber sendNext:@(i)];    }    [subscriber sendCompleted];    return nil;}];//创建一个发送信号的信号，信号的信号RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    [subscriber sendNext:signal];    [subscriber sendCompleted];    return nil;}];[signalOfSignals subscribeNext:^(id  _Nullable x) {    //不使用flattenMap，会打印出内部信号    NSLog(@"订阅signalOfSignals：%@",x);}];[[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) {    return [value filter:^BOOL(NSNumber*  _Nullable value) {        NSLog(@"filter：%@",value);        return [value integerValue] &gt;= 2 ? YES: NO;    }];}] subscribeNext:^(id  _Nullable x) {    //使用flattenMap，会打印内部信号的值    NSLog(@"使用flattenMap后订阅signalOfSignals：%@",x);}];/*2020-06-08 17:54:26.211401+0800 RACExample[51286:408356] 订阅signalOfSignals：&lt;RACDynamicSignal: 0x6000011c3880&gt; name: 2020-06-08 17:54:26.213350+0800 RACExample[51286:408356] filter：02020-06-08 17:54:26.213911+0800 RACExample[51286:408356] filter：12020-06-08 17:54:26.214308+0800 RACExample[51286:408356] filter：22020-06-08 17:54:26.214501+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：22020-06-08 17:54:26.214642+0800 RACExample[51286:408356] filter：32020-06-08 17:54:26.214780+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：32020-06-08 17:54:26.214903+0800 RACExample[51286:408356] filter：42020-06-08 17:54:26.215048+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：42020-06-08 17:54:26.215221+0800 RACExample[51286:408356] filter：52020-06-08 17:54:26.215357+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：5*/信号操作时间:delay(延迟)  延迟发送next。[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {    [subscriber sendNext:@(1)];    [subscriber sendCompleted];    return nil;}] delay:2] subscribeNext:^(id  _Nullable x) {    NSLog(@"subscribeNext:%@", x);}];信号操作时间:interval(定时)  每隔一段时间发出信号-(void)test_interval_onScheduler{    [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDate * _Nullable x) {        NSLog(@"interval -- %@", x);    }];    // 保证上面的延时操作得以完成    [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        return nil;    }] asynchronouslyWaitUntilCompleted:nil];}/*2019-08-07 10:10:38.795691+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:38 20192019-08-07 10:10:39.796486+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:39 20192019-08-07 10:10:40.796486+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:40 20192019-08-07 10:10:41.796472+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:41 20192019-08-07 10:10:42.796452+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:42 20192019-08-07 10:10:43.796631+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:43 20192019-08-07 10:10:44.796494+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:44 20192019-08-07 10:10:45.796493+0800 RACDemo02[45596:1122009] interval -- Wed Aug  7 10:10:45 2019*/信号操作时间:timeout(超时)  timeout：超时，可以让一个信号在一定的时间后，自动报错。[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{        [subscriber sendNext:@1];        [subscriber sendCompleted];    }];    return nil;}] timeout:2.0 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id  _Nullable x) {    NSLog(@"subscribeNext：%@",x);} error:^(NSError * _Nullable error) {    NSLog(@"error：%@",error.localizedDescription);} completed:^{    NSLog(@"completed");}];/*error：The operation couldn’t be completed. (RACSignalErrorDomain error 1.)*/信号过滤:distinctUntilChanged  distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。// distinctUntilChanged 只有输入合法才能进行打印RACSignal *validSearchSignal = [[RACObserve(self, searchText) map:^id _Nullable(NSString*  _Nullable value) {    return @(value.length &gt; 3);}]distinctUntilChanged];[validSearchSignal subscribeNext:^(id  _Nullable x) {    NSLog(@"search text is valid %@", x);}];self.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal signalBlock:^RACSignal * _Nonnull(id  _Nullable input) {    return [self executeSearchSignal];}];信号过滤:ignore(忽略)  忽略完某些值的信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。[[self.textField.rac_textSignal ignore:@"123"] subscribeNext:^(NSString * _Nullable x) {   NSLog(@"%@",x);}];/*2020-05-28 19:02:21.305235+0800 RACExample[54835:11820168] 12020-05-28 19:02:22.011735+0800 RACExample[54835:11820168] 122020-05-28 19:02:23.618772+0800 RACExample[54835:11820168] 12342020-05-28 19:02:24.323828+0800 RACExample[54835:11820168] 123452020-05-28 19:02:25.367480+0800 RACExample[54835:11820168] 1234562020-05-28 19:02:26.316891+0800 RACExample[54835:11820168] 123452020-05-28 19:02:26.874963+0800 RACExample[54835:11820168] 12342020-05-28 19:02:29.028761+0800 RACExample[54835:11820168] 122020-05-28 19:02:29.442549+0800 RACExample[54835:11820168] 12020-05-28 19:02:30.029542+0800 RACExample[54835:11820168] */信号过滤:filter(过滤)  过滤信号，使用它可以获取满足条件的信号,符合条件的信号才能发出消息。RAC(self.textLabel,text) = [self.textField.rac_textSignal filter:^BOOL(NSString * _Nullable value) {    NSLog(@"%@",value);    return [value isEqualToString:@"12345"];}];[[self.textField.rac_textSignal filter:^BOOL(NSString * _Nullable value) {    return [value isEqualToString:@"12345"];}] subscribeNext:^(NSString * _Nullable x) {    NSLog(@"%@",x);}];信号合并:combineLatest(结合)、reduce(聚合)  combineLatest: 将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。combineLatest 功能和 zipWith一样。 reduce:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值,一般都是先结合再聚合。combineLatest示例:-(void)test_combineLatest_1{    RACReplaySubject * subjectA = [RACReplaySubject subject];    RACReplaySubject * subjectB = [RACReplaySubject subject];    RACReplaySubject * subjectC = [RACReplaySubject subject];        // 三个对象同时发送信号，缺一不可    [subjectA sendNext:@1];    [subjectB sendNext:@2];    [subjectC sendNext:@3];    [[RACSignal combineLatest:@[subjectA,subjectB,subjectC]] subscribeNext:^(id  _Nullable x) {        // x 的类型为 RACTuple 元组类 -&gt; RACOneTuple、RACTwoTuple、RACThreeTuple、RACFourTuple         NSLog(@"%@",x);    }];    /*     2020-05-28 18:54:23.910080+0800 RACExample[54517:11813771] &lt;RACTuple: 0x600002aa1410&gt; (         1,         2,         3     )     */}combineLatest、reduce示例:- (void)viewDidLoad {    [super viewDidLoad];    RACReplaySubject * subjectA = [RACReplaySubject subject];    RACReplaySubject * subjectB = [RACReplaySubject subject];    RACReplaySubject * subjectC = [RACReplaySubject subject];        // 三个对象同时发送信号，缺一不可    [subjectA sendNext:@"邮件AA"];    [subjectB sendNext:@"邮件BB"];    [subjectC sendNext:@"邮件CC"];    // 遵守 NSFastEnumeration 协议的类都可成为数组    // reduce block 参数可以自己根据信号设置    [[RACSignal combineLatest:@[subjectA,subjectB,subjectC] reduce:^id (NSString * signalA,NSString * signalB,NSString * signalC){        // 把这 三个中任意 一个发出的信号值 聚合成一个值 NSString 类型        return [NSString stringWithFormat:@"A = %@ , B = %@ , C = %@",signalA , signalB , signalC];    }] subscribeNext:^(id  _Nullable x) {        NSLog(@"聚合后三个值变成一个 NSString 类型的值： %@",x);    }];        // 或者    RAC(self.textLabel,text) = [RACSignal combineLatest:@[subjectA,subjectB,subjectC] reduce:^id (NSString * signalA,NSString * signalB,NSString * signalC){        return [NSString stringWithFormat:@"A = %@ , B = %@ , C = %@",signalA , signalB , signalC];    }];}/*2020-05-28 14:28:01.127620+0800 RACExample[44949:11647817] 聚合后三个值变成一个 NSString 类型的值： A = 邮件AA , B = 邮件BB , C = 邮件CC*/信号合并:zipWith(压缩)  把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 使用 zipWith 时，两个信号必须同时发出信号内容-(void)test_zipWith{    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@1];        [subscriber sendCompleted];        return nil;    }];        RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@2];        return nil;    }];    [[signalA zipWith:signalB] subscribeNext:^(id  _Nullable x) {        // x 的类型为 RACTuple 元组类 -&gt; RACOneTuple、RACTwoTuple、RACThreeTuple、RACFourTuple         NSLog(@"%@",x);    }];}/*2020-05-28 18:38:30.014387+0800 RACExample[53947:11801545] &lt;RACTwoTuple: 0x600000560900&gt; (    1,    2)*/信号合并:merge(合并)  把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 只要有一个信号被发出就会被监听- (void)viewDidLoad {    [super viewDidLoad];    RACReplaySubject * subjectA = [RACReplaySubject subject];    RACReplaySubject * subjectB = [RACReplaySubject subject];    RACReplaySubject * subjectC = [RACReplaySubject subject];        // 三个对象发送信号（只需其中一个或多个发送信号时，合并的 信号对象 都可以在订阅的 block 接收到信息）    [subjectC sendNext:@"CC"];    [subjectA sendNext:@"AA"];    [subjectB sendNext:@"BB"];        // 合并两个信号对象变成一个接收信号对象 subjectD , subjectD 订阅 接收 subjectB 和 subjectA 发送的信号,信号输入的顺序和信号merge的顺序有关联。    [[[subjectB merge:subjectA] merge:subjectC] subscribeNext:^(id  _Nullable x) {        NSLog(@"%@",x);    }];}/*2020-05-28 14:16:49.377200+0800 RACExample[44542:11640972] BB2020-05-28 14:16:49.377353+0800 RACExample[44542:11640972] AA2020-05-28 14:16:49.377509+0800 RACExample[44542:11640972] CC*/ 信号拼接:then(连接)  使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。  then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值。[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    NSLog(@"signalOne");    [subscriber sendNext:@"signalOne"];    [subscriber sendCompleted];    return nil;}] subscribeNext:^(id  _Nullable x) {    NSLog(@"信号被激活:%@",x);}];/*2020-06-08 18:28:17.835711+0800 RACExample[52619:427692] signalOne2020-06-08 18:28:17.836206+0800 RACExample[52619:427692] 信号被激活:signalOne*/添加一个then信号：[[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    NSLog(@"signalOne");    [subscriber sendNext:@"signalOne"];    [subscriber sendCompleted];    return nil;}] then:^RACSignal * _Nonnull{    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"signalTwo");        [subscriber sendNext:@"signalTwo"];        [subscriber sendCompleted];        return nil;    }];}] then:^RACSignal * _Nonnull{    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"signalThree");        [subscriber sendNext:@"signalThree"];        [subscriber sendCompleted];        return nil;    }];}] subscribeNext:^(id  _Nullable x) {    NSLog(@"信号被激活:%@",x);}];/*2020-06-08 18:34:42.158566+0800 RACExample[52963:432992] signalOne2020-06-08 18:34:42.159054+0800 RACExample[52963:432992] signalTwo2020-06-08 18:34:42.159283+0800 RACExample[52963:432992] signalThree2020-06-08 18:34:42.159633+0800 RACExample[52963:432992] 信号被激活:signalThree*/信号拼接:concat(合并)  使用concat可以按序拼接多个信号，拼接后的信号按序执行。  只有前面的信号执行sendCompleted，后面的信号才会被激活。- (void)viewDidLoad {    [super viewDidLoad];        RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        [subscriber sendNext:@"signalOne"];        [subscriber sendCompleted];        return nil;    }];    RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        [subscriber sendNext:@"signalTwo"];//        [subscriber sendCompleted];        return nil;    }];    RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        [subscriber sendNext:@"signalThree"];        [subscriber sendCompleted];        return nil;    }];    //拼接了三个信号，订阅之后，三个信号依次激活    RACSignal *concatSignal = [[signalOne concat:signalTwo] concat:signalThree];    [concatSignal subscribeNext:^(id  _Nullable x) {        NSLog(@"信号被激活:%@",x);    }];}/*2020-06-08 18:20:53.103639+0800 RACExample[52202:421372] 信号被激活:signalOne2020-06-08 18:20:53.103922+0800 RACExample[52202:421372] 信号被激活:signalTwo*/从上面代码看出signalOne-&gt;signalTwo-&gt;signalThree按照顺序连接，但是在信号signalTwo中没发送sendCompleted，所以后面的信号signalThree没有被激活。RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {    [subscriber sendNext:@"signalTwo"];    [subscriber sendCompleted];    return nil;}];/*2020-06-08 18:23:40.588477+0800 RACExample[52340:423182] 信号被激活:signalOne2020-06-08 18:23:40.589093+0800 RACExample[52340:423182] 信号被激活:signalTwo2020-06-08 18:23:40.589539+0800 RACExample[52340:423182] 信号被激活:signalThree*/RACObserve  RACObserve : KVO 监听属性内容变化[RACObserve(self.textLabel, text) subscribeNext:^(id  _Nullable x) {    NSLog(@"KVO 监听到 age 内容发生变化 ，变为 %@ , thread = %@",x,[NSThread currentThread]);}];其他使用  replay重放：当一个信号被多次订阅,反复播放内容RACCommand  RACCommand：处理事件的操作,和UI关联.(主线程中执行)，最常用于两个地方，监听按钮点击，网络请求。@property (nonatomic, strong, readonly) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;@property (nonatomic, strong, readonly) RACSignal&lt;NSNumber *&gt; *executing;@property (nonatomic, strong, readonly) RACSignal&lt;NSNumber *&gt; *enabled;@property (nonatomic, strong, readonly) RACSignal&lt;NSError *&gt; *errors;@property (atomic, assign) BOOL allowsConcurrentExecution;- (instancetype)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;// 初始化RACCommand的入参enabledSignal就决定了RACCommand是否能开始执行。入参enabledSignal就是触发条件。- (instancetype)initWithEnabled:(nullable RACSignal&lt;NSNumber *&gt; *)enabledSignal signalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;- (RACSignal&lt;ValueType&gt; *)execute:(nullable InputType)input;executionSignals:是一个高阶信号，所以在使用的时候需要进行降阶操作(flatten，switchToLatest，concat)，降阶的方式根据需求来选取。一般选择的原则：一般不允许并发(dispatch_queue_concurrent)的RACCommand使用switchToLatest，允许并发的使用flatten。executing:表示了当前RACCommand是否在执行，信号里面的值都是BOOL类型的。YES表示的是RACCommand正在执行过程中，命名也说明的是正在进行时ing。NO表示的是RACCommand没有被执行或者已经执行结束。enabled: 信号就是一个开关，判断RACCommand是否可用:  RACCommand 初始化传入的enabledSignal信号，如果返回NO，那么enabled信号就返回NO。  RACCommand开始执行中，allowsConcurrentExecution为NO，那么enabled信号就返回NO。  除去以上2种情况以外，enabled信号基本都是返回YES。errors: 信号就是RACCommand执行过程中产生的错误信号。  在对RACCommand进行错误处理的时候，我们不应该使用subscribeError:对RACCommand的executionSignals 进行错误的订阅，因为executionSignals这个信号是不会发送error事件的。// 用subscribeNext:去订阅错误信号。[commandSignal.errors subscribeNext:^(NSError *x) {         NSLog(@"ERROR! --&gt; %@",x);}];allowsConcurrentExecution: 用来表示当前RACCommand是否允许并发执行。默认值是NO。按照上面说的则enabled的值也会为NO。allowsConcurrentExecution在具体实现中是用的volatile原子的操作，在实现中重写了它的get和set方法。// 重写 get方法- (BOOL)allowsConcurrentExecution {    return _allowsConcurrentExecution != 0;}// 重写 set方法- (void)setAllowsConcurrentExecution:(BOOL)allowed {    [self willChangeValueForKey:@keypath(self.allowsConcurrentExecution)];        if (allowed) {        // OSAtomicOr32Barrier是原子运算，它的意义是进行逻辑的“或”运算。通过原子性操作访问被volatile修饰的_allowsConcurrentExecution对象即可保障函数只执行一次。        OSAtomicOr32Barrier(1, &amp;_allowsConcurrentExecution);    } else {        // OSAtomicAnd32Barrier是原子运算，它的意义是进行逻辑的“与”运算。        OSAtomicAnd32Barrier(0, &amp;_allowsConcurrentExecution);    }        [self didChangeValueForKey:@keypath(self.allowsConcurrentExecution)];}initWithSignalBlock:与initWithEnabled:signalBlock:的区别：- (instancetype)initWithSignalBlock:(RACSignal&lt;id&gt; * (^)(id input))signalBlock {    return [self initWithEnabled:nil signalBlock:signalBlock];// nil 相当于：[RACSignal return:@YES]}使用RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) {    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"发送信号：%@",input);//2        [subscriber sendNext:input];        [subscriber sendError:[NSError errorWithDomain:@"" code:0 userInfo:@{NSLocalizedDescriptionKey:@"----"}]];        [subscriber sendCompleted];        return nil;    }];}];[command.executionSignals subscribeNext:^(id  _Nullable x) {        NSLog(@"收到信号(subscribeNext)：%@",x);// 我们可以在这里把处理事件(网络请求、逻辑处理)之前的逻辑(showHUD...)放到这。        [x subscribeNext:^(id  _Nullable x) {        NSLog(@"x-收到信号(subscribeNext)：%@",x);// 收到信号B：1    } error:^(NSError * _Nullable error) {        NSLog(@"x-收到信号(error)：%@",x);//收不到error，因为 executionSignals 不会处理 error    } completed:^{        NSLog(@"x-收到信号(completed)");    }];} error:^(NSError * _Nullable error) {    NSLog(@"收到信号(error)：%@",error.localizedDescription);//收不到error，因为 executionSignals 不会处理 error} completed:^{    NSLog(@"收到信号(completed)");}];[command execute:@1];/*收到信号(subscribeNext)：&lt;RACDynamicSignal: 0x60000318f5a0&gt; name: 发送信号：1x-收到信号(subscribeNext)：1x-收到信号(completed)收到信号(completed)*/换一种方式进行信号处理：RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) {    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"发送信号：%@",input);//2        [subscriber sendNext:input];        [subscriber sendError:[NSError errorWithDomain:@"" code:0 userInfo:@{NSLocalizedDescriptionKey:@"----"}]];        [subscriber sendCompleted];        return nil;    }];}];// 通过 switchToLatest 把高阶信号降阶处理。[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) {    NSLog(@"收到信号(switchToLatest)：%@",x);}];[command.errors subscribeNext:^(NSError * _Nullable x) {    NSLog(@"收到信号(errors)：%@",x.localizedDescription);}];[command.executing subscribeNext:^(NSNumber * _Nullable x) {    if([x boolValue] == YES){        NSLog(@"RACCommand命令正在执行...");    }else{        NSLog(@"RACCommand命令不在执行中！！！");    }}];[command execute:@1];/*RACCommand命令不在执行中！！！RACCommand命令正在执行...     &lt;==== 我们可以在这里把处理事件(网络请求、逻辑处理)之前的逻辑(showHUD...)放到这。发送信号：1收到信号(switchToLatest)：1收到信号(errors)：----RACCommand命令不在执行中！！！*/我们对executing进行一下处理，去掉无用的触发。[[[command.executing skip:1] take:1] subscribeNext:^(NSNumber * _Nullable x) {    if([x boolValue] == YES){        NSLog(@"RACCommand命令正在执行...");    }else{        NSLog(@"RACCommand命令不在执行中！！！");    }}];/*2020-06-08 17:00:00.488046+0800 RACExample[49056:380458] RACCommand命令正在执行...2020-06-08 17:00:00.488513+0800 RACExample[49056:380458] 发送信号：12020-06-08 17:00:00.488740+0800 RACExample[49056:380458] 收到信号(switchToLatest)：12020-06-08 17:00:00.489372+0800 RACExample[49056:380458] 收到信号(errors)：----*/或者直接订阅信号：[[command execute:@1] subscribeNext:^(id  _Nullable x) {    NSLog(@"接收信号(subscribeNext)：%@",x);} error:^(NSError * _Nullable error) {    NSLog(@"接收信号(error)：%@",error.localizedDescription);} completed:^{    NSLog(@"接收信号(completed)");}];/*发送信号：1接收信号(subscribeNext)：1接收信号(error)：----*/RACChannelRACChannel实现双向绑定Foundation涉及Foundation相关的RAC分类:NSArray、NSData、NSDictionary、NSEnumerator、NSFileHandle、NSIndexSet、NSInvocation、NSNotificationCenter、NSObject、NSOrderedSet、NSSet、NSString、NSURLConnection、NSUserDefaults。NSArray+RACSequenceAdditions.hNSData+RACSupport.hNSDictionary+RACSequenceAdditions.hNSEnumerator+RACSequenceAdditions.hNSFileHandle+RACSupport.hNSIndexSet+RACSequenceAdditions.hNSInvocation+RACTypeParsing.hNSNotificationCenter+RACSupport.hNSObject+RACDeallocating.hNSObject+RACDescription.hNSObject+RACKVOWrapper.hNSObject+RACLifting.hNSObject+RACPropertySubscribing.hNSObject+RACSelectorSignal.hNSOrderedSet+RACSequenceAdditions.hNSSet+RACSequenceAdditions.hNSString+RACKeyPathUtilities.hNSString+RACSequenceAdditions.hNSString+RACSupport.hNSURLConnection+RACSupport.hNSUserDefaults+RACSupport.hNSObjectNSObject+RACDeallocating.hNSObject+RACDescription.hNSObject+RACKVOWrapper.hNSObject+RACLifting.hNSObject+RACPropertySubscribing.hNSObject+RACSelectorSignal.hNSObject+RACLifting  等待成所有的 RACSignal 对象发送完信号再执行方法) (主程中执行)- (RACSignal *)rac_liftSelector:(SEL)selector withSignals:(RACSignal *)firstSignal, ... NS_REQUIRES_NIL_TERMINATION;- (RACSignal *)rac_liftSelector:(SEL)selector withSignalsFromArray:(NSArray&lt;RACSignal *&gt; *)signals;- (RACSignal *)rac_liftSelector:(SEL)selector withSignalOfArguments:(RACSignal&lt;RACTuple *&gt; *)arguments;- (IBAction)test_rac_lift:(id)sender {    RACSignal * signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        // 现在想发出信号了        [subscriber sendNext:@"网络请求数据 1"];        // 不需要释放操作        return nil ;    }];        RACSignal * signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        // 现在想发出信号了        [subscriber sendNext:@"网络请求数据 2"];        // 不需要释放操作        return nil ;    }];    [self rac_liftSelector:@selector(updateUIWithSignalOneMessage:signalTwoMessage:) withSignalsFromArray:@[signalOne,signalTwo]];}// 当所有数据都拿到手后更新UI , 传的数据就是 signalOne 和 signalTwo 发出来的信号数据 ，(所以当前设计的接收方法 也必需要有两个参数，发出的信号按顺序 传参)// 假如当前对象方法只设计 传一个参数，那么就会导致崩溃-(void)updateUIWithSignalOneMessage:(id)signalOneMessage signalTwoMessage:(id)signalTwoMessage{    NSLog(@"signalOneMessage = %@ , signalTwoMessage = %@ , thread = %@",signalOneMessage,signalTwoMessage,[NSThread currentThread]);}//signalOneMessage = 网络请求数据 1 , signalTwoMessage = 网络请求数据 2 , thread = &lt;NSThread: 0x600002f704c0&gt;{number = 1, name = main}NSNotificationCenter  RAC 把监听通知的方法改成了 block 形式// NSNotificationCenter+RACSupport.h- (RACSignal&lt;NSNotification *&gt; *)rac_addObserverForName:(nullable NSString *)notificationName object:(nullable id)object;- (IBAction)test_rac_addObserverForName:(id)sender {    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardDidHideNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) {        NSLog(@"NSNotification 1 x = %@",x.userInfo);    }];    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardDidHideNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) {        NSLog(@"NSNotification 2 x = %@",x.userInfo);    }];    [[NSNotificationCenter defaultCenter] postNotificationName:UIKeyboardDidHideNotification object:nil];        // NSNotification 1 x = (null)    // NSNotification 2 x = (null)}NSStringNSString+RACKeyPathUtilities.hNSString+RACSequenceAdditions.hNSString+RACSupport.hUIKit涉及UIKit相关的RAC分类：UIActionSheet、UIAlertView、UIBarButtonItem、UIButton、UICollectionReusableView、UIControl、UIControl、UIDatePicker、UIGestureRecognizer、UIImagePickerController、UIRefreshControl、UISegmentedControl、UISlider、UIStepper、UISwitch、UITableViewCell、UITableViewHeaderFooterView、UITextField、UITextView。UIActionSheet+RACSignalSupport.hUIAlertView+RACSignalSupport.hUIBarButtonItem+RACCommandSupport.hUIButton+RACCommandSupport.hUICollectionReusableView+RACSignalSupport.hUIControl+RACSignalSupport.hUIControl+RACSignalSupportPrivate.hUIDatePicker+RACSignalSupport.hUIGestureRecognizer+RACSignalSupport.hUIImagePickerController+RACSignalSupport.hUIRefreshControl+RACCommandSupport.hUISegmentedControl+RACSignalSupport.hUISlider+RACSignalSupport.hUIStepper+RACSignalSupport.hUISwitch+RACSignalSupport.hUITableViewCell+RACSignalSupport.hUITableViewHeaderFooterView+RACSignalSupport.hUITextField+RACSignalSupport.hUITextView+RACSignalSupport.hUIControl+RACSignalSupportPrivate- (RACChannelTerminal *)rac_channelForControlEvents:(UIControlEvents)controlEvents key:(NSString *)key nilValue:(nullable id)nilValue;// 按钮点击响应[[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { }];UITextField+RACSignalSupport- (RACSignal&lt;NSString *&gt; *)rac_textSignal;- (RACChannelTerminal&lt;NSString *&gt; *)rac_newTextChannel;- (void)viewDidLoad {    [super viewDidLoad];    @weakify(self)    [[self.textField rac_textSignal] subscribeNext:^(NSString * _Nullable x) {        @strongify(self)        NSLog(@"text = %@ , textField.text = %@ , thread = %@",x,self.textField.text,[NSThread currentThread]);    }];    RAC(self.textLabel,text) = self.textField.rac_textSignal;}信号相关类RACDynamicSignal.hRACEmptySignal.hRACErrorSignal.hRACGroupedSignal.hRACReturnSignal.hRACSignal+Operations.hRACSignal.hRACSignalProvider.dRACSignalSequence.hrac_deallocDisposable、rac_deallocDisposable、rac_prepareForReuseSignal  NSObject : rac_deallocDisposable  NSObject : rac_willDeallocSignal  UITableViewCell : rac_prepareForReuseSignalTips@interface HomeViewModel : NSObject@property (nonatomic, copy) NSString *searchConditons;@property (nonatomic, strong, readonly) RACSignal  *searchBtnEnableSignal;@end@implementation HomeViewModel-(instancetype)init{    if (self = [super init]) {        [self setUp];    }    return self;}- (void)setUp{    [self setupSearchBtnEnableSignal];}- (void)setupSearchBtnEnableSignal {    _searchBtnEnableSignal = [RACSignal combineLatest:@[RACObserve(self, searchConditons)] reduce:^id(NSString *searchConditions){        return @(searchConditions.length);    }];}@end// =====================================================@interface MovieViewModel : NSObject@property (nonatomic, strong, readonly) RACCommand *requestCommand;@property (nonatomic, copy, readonly) NSArray *movies;@end@implementation MovieViewModel-(instancetype)init{    if (self = [super init]) {        [self setup];    }    return self;}- (void)setup {    _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        NSLog(@"%@", input);        RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {            NetworkManager *manager = [NetworkManager manager];            [manager getDataWithUrl:@"https://api.douban.com/v2/movie/search" parameters:input success:^(id json) {                [subscriber sendNext:json];                [subscriber sendCompleted];            } failure:^(NSError *error) {                            }];                        return nil;        }];        return [requestSignal map:^id _Nullable(id  _Nullable value) {            NSMutableArray *dictArray = value[@"subjects"];            NSArray *modelArray = [dictArray.rac_sequence map:^id(id value) {                return [Movie movieWithDict:value];            }].array;           NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"year" ascending:NO];            _movies = [modelArray sortedArrayUsingDescriptors:@[sortDescriptor]];            NSLog(@"%@",_movies.description);                        return nil;        }];    }];}@end在两个VM中，一个用的是RACSignal，一个用的是RACCommand：  RACSignal是单向的，就像1个人在做演讲，观众听到就结束了  RACCommand是双向的，演讲者做演讲，下面的观众听到后还反馈了意见，而演讲者对反馈还做了回复。(V中发出命令，VM收到命令后进行网络请求，并将获取的网络数据包发送出去，V对收到的数据进行解析和显示)。RAC&amp;MVVM开发规约VM层// =============================.h=============================@interface WLMSelectedApplyMerchantVM :NSObject@property (nonatomic, strong, readonly) RACCommand *requestCommand;@property (strong, nonatomic, readonly) RACSubject *messageSubject;@end// =============================.m=============================@interface WLMSelectedApplyMerchantVM()@property (nonatomic, strong, readwrite) RACCommand *requestCommand;@property (strong, nonatomic, readwrite) RACSubject *messageSubject;@end@implementation WLMSelectedApplyMerchantVM#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}-(void)dealloc{    [self.requestCommand rac_deallocDisposable];    [self.messageSubject rac_deallocDisposable];}- (void)racInit {    //@weakify(self);    _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {            //@strongify(self);            // Code here...                        return [RACDisposable disposableWithBlock:^{            }];        }];    }];}#pragma mark - Publish Methods#pragma mark - Private Methods#pragma mark - Getter-(RACSubject *)messageSubject{    if (!_messageSubject) {        _messageSubject = [RACSubject subject];    }    return _messageSubject;}#pragma mark - Stter@endV层Controller// =============================.h=============================@interface LoginViewController : UIViewController- (instancetype)initWithViewModel:(RACAndMVVMViewModel*)viewModel;@end// =============================.m=============================@interface LoginViewController ()@property(nonatomic, strong) RACAndMVVMViewModel *viewModel;@end@implementation LoginViewController#pragma mark - life cycle- (instancetype)initWithViewModel:(RACAndMVVMViewModel*)viewModel{    if (self == [super init]) {        _viewModel = viewModel;    }    return self;}- (void)viewDidLoad {    [super viewDidLoad];    [self segInitViews];    [self bindViewModel];}#pragma mark - Init Views-(void)segInitViews{}#pragma mark - Layout- (void)updateViewConstraints {    [super updateViewConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {}#pragma mark - getter-(RACAndMVVMViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[RACAndMVVMViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@end有些方案会把Controller中的View也自定义出来，成为主View，具体样例：VM层：#pragma mark - ====================VM层====================@interface LoginMainViewModel : NSObject// Demo RACSubject@property (nonatomic, strong) RACSubject *pushSubject;@end@implementation LoginMainViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {}#pragma mark - getter- (RACSubject *)pushSubject {    if (!_pushSubject) {        _pushSubject = [RACSubject subject];    }    return _pushSubject;}#pragma mark setter@end主View层：#pragma mark - ====================V层====================@interface LoginMainView : UIView// Demo Button@property(nonatomic,strong) UIButton* button;@property(nonatomic,strong) LoginMainViewModel* viewModel;- (instancetype)initWithViewModel:(LoginMainViewModel*)viewModel;@end@implementation LoginMainView- (instancetype)initWithViewModel:(LoginMainViewModel*)viewModel {    if (self == [super init]) {        _viewModel = viewModel;        [self segInitViews];        [self updateConstraints];        [self bindViewModel];    }    return self;}#pragma mark - Init Views-(void)segInitViews{}#pragma mark - Layout- (void)updateConstraints {    [super updateConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    // Demo sendNext    [[self.button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        [self.viewModel.pushSubject sendNext:@"1"];    }];}#pragma mark - getter-(LoginMainViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[LoginMainViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@endController层：#pragma mark - ====================V层====================@interface LoginViewController ()@property (nonatomic, strong) LoginMainView *mainView;@property(nonatomic, strong) LoginMainViewModel *viewModel;@end@implementation LoginViewController#pragma mark - life cycle- (void)viewDidLoad {    [super viewDidLoad];    [self segInitViews];    [self bindViewModel];}#pragma mark - Init Views-(void)segInitViews{    [self.view addSubview:self.mainView];}#pragma mark - Layout- (void)updateViewConstraints {    [self.mainView mas_makeConstraints:^(MASConstraintMaker *make) {        make.edges.mas_equalTo(self.view);    }];    [super updateViewConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    // Demo subscribeNext    @weakify(self);    [self.viewModel.pushSubject subscribeNext:^(id  _Nullable x) {        @strongify(self);        [self.navigationController pushViewController:[UIViewController new] animated:YES];    }];}#pragma mark - getter- (LoginMainView *)mainView {    if (!_mainView) {        _mainView = [[LoginMainView alloc] initWithViewModel:self.viewModel];    }    return _mainView;}-(LoginMainViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[LoginMainViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@end自定义UIView@interface  LoginTableView: UIView@property(nonatomic,strong) LoginTableViewModel* viewModel;- (instancetype)initWithViewModel:(LoginTableViewModel*)viewModel;@end@implementation LoginTableView- (instancetype)initWithViewModel:(LoginTableViewModel*)viewModel {    if (self == [super init]) {        _viewModel = viewModel;        [self segInitViews];        [self updateConstraints];        [self bindViewModel];    }    return self;}#pragma mark - Init Views-(void)segInitViews{}#pragma mark - Layout- (void)updateConstraints {    [super updateConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {}#pragma mark - getter-(LoginTableViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[LoginTableViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@end自定义复用机制UIView  有复用机制的View：UICollectionviewCell、UITableViewCell…,因为有复用机制，会有部份cell不会走init方法，而是直接走cell复用池。@interface  LoginTableViewCell: UITableViewCell@property (strong, nonatomic) NSIndexPath *indexPath;@property(nonatomic,strong) CircleListMainViewCellViewModel* viewModel;+(NSString*)reuseIdentifier;+(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath;@end@implementation LoginTableViewCell#pragma mark - Init Views+(NSString*)reuseIdentifier{    return NSStringFromClass([self class]);}+(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{    CircleListMainViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier]];    if (!cell) {        cell = [[self alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]];    }    cell.indexPath = indexPath;    return cell;}-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        self.selectionStyle = UITableViewCellSelectionStyleNone;        [self segInitViews];        [self updateConstraints];    }    return self;}-(void)segInitViews{}#pragma mark - Layout- (void)updateConstraints {    [super updateConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {}#pragma mark - getter#pragma mark setter-(void)setViewModel:(LoginTableViewCellViewModel *)viewModel{    _viewModel = viewModel;    if (!viewModel)  return;    [self bindViewModel];}@endMVVM&amp;RAC使用设计  一个V(ViewController也是一个V)对应一个VM，V界面元素属性与 VM 处理后的数据属性绑定。  ViewController对应的VM算是主VM。主 VM 承担了网络请求、点击事件协议、初始化子 VM 并且给子VM的属性赋初值；网络请求成功返回数据过后，主 ViewModel 还需要给子 ViewModel 的属性赋予新的值。@interface mainViewModel : NSObject@property (nonatomic, strong) MineHeaderViewModel *mineHeaderViewModel;@property (nonatomic, strong) NSArray&lt;MineTopCollectionViewCellViewModel *&gt; *dataSorceOfMineTopCollectionViewCell;@property (nonatomic, strong) NSArray&lt;MineDownCollectionViewCellViewModel *&gt; *dataSorceOfMineDownCollectionViewCell;@property (nonatomic, strong) RACCommand *autoLoginCommand;//用于网络请求@property (nonatomic, strong) RACSubject *pushSubject;//相当于协议，这里用于点击事件的代理@end示例：列表刷新具体效果：2020-06-03 14:20:34.431310+0800 RACExample[29796:2244630] refreshDataCommand execute2020-06-03 14:20:34.464985+0800 RACExample[29796:2244630] executing subscribeNext2020-06-03 14:20:34.465376+0800 RACExample[29796:2244630] RefreshLoading2020-06-03 14:20:35.088477+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext2020-06-03 14:20:35.088770+0800 RACExample[29796:2244630] switchToLatest subscribeNext2020-06-03 14:20:35.092880+0800 RACExample[29796:2244630] RefreshUI2020-06-03 14:20:35.093239+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted2020-06-03 14:20:37.458024+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext2020-06-03 14:20:37.458241+0800 RACExample[29796:2244630] switchToLatest subscribeNext2020-06-03 14:20:37.458642+0800 RACExample[29796:2244630] RefreshUI2020-06-03 14:20:37.458772+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted2020-06-03 14:20:38.549670+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext2020-06-03 14:20:38.549901+0800 RACExample[29796:2244630] switchToLatest subscribeNext2020-06-03 14:20:38.550304+0800 RACExample[29796:2244630] RefreshUI2020-06-03 14:20:38.550600+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted2020-06-03 14:20:40.055668+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext2020-06-03 14:20:40.055887+0800 RACExample[29796:2244630] switchToLatest subscribeNext2020-06-03 14:20:40.056336+0800 RACExample[29796:2244630] RefreshUI2020-06-03 14:20:40.056514+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted他们的项目结构：├── Controller│   ├── CircleListViewController.h│   └── CircleListViewController.m├── Model│   ├── DouBanTheatersModel.h│   └── DouBanTheatersModel.m├── View│   ├── CircleListMainView.h│   ├── CircleListMainView.m│   ├── CircleListMainViewCell.h│   └── CircleListMainViewCell.m└── ViewModel    ├── CircleListMainViewCellViewModel.h    ├── CircleListMainViewCellViewModel.m    ├── CircleListMainViewModel.h    └── CircleListMainViewModel.mCircleListViewController@interface CircleListViewController ()@property (nonatomic, strong) CircleListMainView *mainView;@property(nonatomic, strong) CircleListMainViewModel *viewModel;@end@implementation CircleListViewController#pragma mark - life cycle- (void)viewDidLoad {    [super viewDidLoad];    [self segInitViews];    [self bindViewModel];}#pragma mark - Init Views-(void)segInitViews{    [self.view addSubview:self.mainView];}#pragma mark - Layout- (void)updateViewConstraints {    [self.mainView mas_makeConstraints:^(MASConstraintMaker *make) {        make.edges.mas_equalTo(self.view);    }];    [super updateViewConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    // 点击 cell 跳转 Controller    @weakify(self);    [[self.viewModel.cellClickSubject takeUntil:self.rac_willDeallocSignal] subscribeNext:^(CircleListMainViewCellViewModel*  _Nullable x) {        @strongify(self);        UIViewController *VC = [UIViewController new];        VC.view.backgroundColor = [UIColor whiteColor];        [self.navigationController pushViewController:VC animated:YES];    }];}#pragma mark - getter- (CircleListMainView *)mainView {    if (!_mainView) {        _mainView = [[CircleListMainView alloc] initWithViewModel:self.viewModel];    }    return _mainView;}-(CircleListMainViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[CircleListMainViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@endViewModelCircleListMainViewModeltypedef enum : NSUInteger {    RefreshLoading, // 正在刷新    RefreshError, // 刷新出错    RefreshUI, // 仅仅刷新UI布局} RefreshDataStatus;@interface CircleListMainViewModel : NSObject@property (nonatomic, strong) RACCommand *refreshDataCommand;@property (nonatomic, strong) RACSubject *refreshDataSubject;@property (nonatomic, strong) RACSubject *cellClickSubject;//点击cell的热信号@property (nonatomic, strong,readonly) NSArray&lt;CircleListMainViewCellViewModel*&gt; *dataArray;@end// ============================.m==========================@interface CircleListMainViewModel()@property (nonatomic, strong) HttpManager *httpManager;@property (nonatomic, strong,readwrite) NSArray&lt;CircleListMainViewCellViewModel*&gt; *dataArray;@endimplementation CircleListMainViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {    // 初始化 RACCommand ，并发起网络请求。    _refreshDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {                        // 网络请求            NSMutableDictionary *parameters = [NSMutableDictionary dictionary];            parameters[@"apikey"] = @"0df993c66c0c636e29ecbb5344252a4a";            [self.httpManager requestNetworkDataWithUrlString:@"/v2/movie/in_theaters" Params:parameters completed:^(id  _Nonnull response, NSError * _Nonnull error) {                if (error) {                    NSLog(@"refreshDataCommand subscriber sendError");                    [subscriber sendError:error];                }else{                    NSLog(@"refreshDataCommand subscriber sendNext");                    [subscriber sendNext:response];                }                NSLog(@"refreshDataCommand subscriber sendCompleted");                [subscriber sendCompleted];            }];                        return [RACDisposable disposableWithBlock:^{            }];        }];    }];        // 信号流：O-O-O-O-O-O，而下面这段就是,跳过第一个信号，并且只执行一次。    [[[_refreshDataCommand.executing skip:1] take:1] subscribeNext:^(NSNumber * _Nullable x) {        NSLog(@"executing subscribeNext");        [self showStatus:@"正在加载..."];    }];        // 进行业务处理    [[[_refreshDataCommand executionSignals] switchToLatest] subscribeNext:^(NSDictionary*  _Nullable response) {        NSLog(@"switchToLatest subscribeNext");                if (!response) {             [self showErrorStatus:@"网络有问题！"];            return;        }                // 把 BO 数据转成 VM        NSMutableArray&lt;CircleListMainViewCellViewModel*&gt;*tempt = [NSMutableArray array];        NSArray *subjects = [response valueForKey:@"subjects"];        for (NSDictionary *object in subjects) {;            CircleListMainViewCellViewModel *cellViewModel = [[CircleListMainViewCellViewModel alloc] init];            cellViewModel.model = [DouBanTheatersModel yy_modelWithJSON:object];            [tempt addObject:cellViewModel];        }        self.dataArray = [NSArray arrayWithArray:tempt];        [self showMessage:@"请求成功！"];    }];        // 错误处理    [_refreshDataCommand.errors subscribeNext:^(NSError * _Nullable x) {        NSLog(@"errors subscribeNext");        [self showErrorStatus:@"网络有问题！"];    }];}-(void)showMessage:(NSString*)message{    [self.refreshDataSubject sendNext:@{@"code":@(RefreshUI),@"msg":message}];}-(void)showStatus:(NSString*)status{    [self.refreshDataSubject sendNext:@{@"code":@(RefreshLoading),@"msg":status}];}-(void)showErrorStatus:(NSString*)error{    [self.refreshDataSubject sendNext:@{@"code":@(RefreshError),@"msg":error}];}#pragma mark - getter-(HttpManager *)httpManager{    if (!_httpManager) {        _httpManager = [[HttpManager alloc] initWithBaseURLString:@"https://api.douban.com"];    }    return _httpManager;}-(RACSubject *)refreshDataSubject{    if (!_refreshDataSubject) {        _refreshDataSubject = [RACSubject subject];    }    return _refreshDataSubject;}-(RACSubject *)cellClickSubject{    if (!_cellClickSubject) {        _cellClickSubject = [RACSubject subject];    }    return _cellClickSubject;}#pragma mark setter@endCircleListMainViewCellViewModel@interface CircleListMainViewCellViewModel : NSObject@property (strong, nonatomic) DouBanTheatersModel *model;@end@implementation CircleListMainViewCellViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {}#pragma mark - getter-(DouBanTheatersModel *)model{    if (!_model) {        _model = [[DouBanTheatersModel alloc] init];    }    return _model;}#pragma mark setter@endViewCircleListMainView@interface CircleListMainView : UIView@property(nonatomic,strong) CircleListMainViewModel* viewModel;- (instancetype)initWithViewModel:(CircleListMainViewModel*)viewModel;@end// ==============================.m================================@interface CircleListMainView()&lt;UITableViewDataSource, UITableViewDelegate&gt;@property (strong, nonatomic) UITableView *mainTableView;@end@implementation CircleListMainView- (instancetype)initWithViewModel:(CircleListMainViewModel*)viewModel {    if (self == [super init]) {        self.backgroundColor = self.superview.backgroundColor;        _viewModel = viewModel;        [self segInitViews];        [self setNeedsUpdateConstraints];        [self updateConstraintsIfNeeded];        [self bindViewModel];    }    return self;}#pragma mark - Init Views-(void)segInitViews{    [self addSubview:self.mainTableView];}#pragma mark - Layout- (void)updateConstraints {    [self.mainTableView mas_makeConstraints:^(MASConstraintMaker *make) {        make.edges.equalTo(self);    }];    [super updateConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    [SVProgressHUD setMinimumDismissTimeInterval:1.0];        // 数据请求    NSLog(@"refreshDataCommand execute");    [self.viewModel.refreshDataCommand execute:nil];    // 数据刷新    [self.viewModel.refreshDataSubject subscribeNext:^(NSDictionary*  _Nullable x) {        [self.mainTableView.mj_header endRefreshing];        [self.mainTableView.mj_footer endRefreshing];                [self.mainTableView reloadData];                NSInteger code = [[x valueForKey:@"code"] integerValue];        NSString* msg = [x valueForKey:@"msg"];                switch (code) {            case RefreshLoading:                NSLog(@"RefreshLoading");                [SVProgressHUD show];                break;            case RefreshError:                NSLog(@"RefreshError");                [SVProgressHUD showErrorWithStatus:msg];                break;            case RefreshUI:                NSLog(@"RefreshUI");                [SVProgressHUD showSuccessWithStatus:msg];                break;            default:                break;        }    }];}#pragma mark - getter-(CircleListMainViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[CircleListMainViewModel alloc]init];    }    return _viewModel;}- (UITableView *)mainTableView {    if (!_mainTableView) {        _mainTableView = [[UITableView alloc] init];        _mainTableView.delegate = self;        _mainTableView.dataSource = self;        _mainTableView.backgroundColor = self.backgroundColor;        _mainTableView.separatorStyle = UITableViewCellSeparatorStyleNone;        _mainTableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{            [self.viewModel.refreshDataCommand execute:nil];        }];        _mainTableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{            [self.viewModel.refreshDataCommand execute:nil];        }];    }    return _mainTableView;}#pragma mark - ====================delegate====================#pragma mark - UITableViewDataSource- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {    return 1;}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {    return self.viewModel.dataArray.count;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {    CircleListMainViewCell *cell = [CircleListMainViewCell cellWithTableView:tableView indexPath:indexPath];    if (self.viewModel.dataArray.count &gt; indexPath.row) {        cell.viewModel = self.viewModel.dataArray[indexPath.row];    }    return cell;}#pragma mark - UITableViewDelegate- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {    return 100;}- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {    if (self.viewModel.dataArray.count &gt; indexPath.row) {        [self.viewModel.cellClickSubject sendNext:self.viewModel.dataArray[indexPath.row]];    }}@endCircleListMainViewCell@interface CircleListMainViewCell : UITableViewCell@property (strong, nonatomic) NSIndexPath *indexPath;@property(nonatomic,strong) CircleListMainViewCellViewModel* viewModel;+(NSString*)reuseIdentifier;+(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath;@end@implementation CircleListMainViewCell#pragma mark - Init Views+(NSString*)reuseIdentifier{    return NSStringFromClass([self class]);}+(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{    CircleListMainViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier]];    if (!cell) {        cell = [[CircleListMainViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]];    }    cell.indexPath = indexPath;    return cell;}-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        [self segInitViews];        [self updateConstraints];    }    return self;}-(void)segInitViews{}#pragma mark - Layout- (void)updateConstraints {    [super updateConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    self.textLabel.text = self.viewModel.model.title;        //RAC(self.textLabel,text) = RACObserve(self.viewModel.model, title); ==&gt; 这个在数据刷新的时候报错！因为KVO的keypath重复绑定。    //RAC(self.textLabel,text) = [RACObserve(self.viewModel.model, title) takeUntil:self.rac_prepareForReuseSignal]; ==&gt; 可以通过这样的方式搞定。    //在cell里面创建的信号加上takeUntil:cell.rac_prepareForReuseSignal，这个是让cell在每次重用的时候都去disposable创建的信号。}#pragma mark - getter#pragma mark setter-(void)setViewModel:(CircleListMainViewCellViewModel *)viewModel{    _viewModel = viewModel;    if (!viewModel)  return;    [self bindViewModel];}@endTableView&amp;UIButton在UITableViewCell中有UIButton按钮，点击按钮出发回调，会有如下一种错误场景：刷新数据时，会重复订阅，导致方法多次触发CircleListMainView:- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {    CircleListMainViewCell *cell = [CircleListMainViewCell cellWithTableView:tableView indexPath:indexPath];    if (self.viewModel.dataArray.count &gt; indexPath.row) {        cell.viewModel = self.viewModel.dataArray[indexPath.row];    }    [cell.viewModel.buttonClickSubject subscribeNext:^(id  _Nullable x) {        NSLog(@"raiseButton subscribeNext--%@",x);    }];    return cell;}CircleListMainViewCell:@implementation CircleListMainViewCell#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {   @weakify(self);   [[self.raiseButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {       @strongify(self);       [self.viewModel.buttonClickSubject sendNext:self.viewModel.model];   }];}@end在UITableViewCell的分类中，有一个属性rac_prepareForReuseSignal，可以解决这一问题。@implementation CircleListMainViewCell#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    @weakify(self);    [[[self.raiseButton rac_signalForControlEvents:UIControlEventTouchUpInside] takeUntil:self.rac_prepareForReuseSignal] subscribeNext:^(__kindof UIControl * _Nullable x) {        @strongify(self);        [self.viewModel.buttonClickSubject sendNext:self.viewModel.model.title];    }];}@endTableView&amp;UITextFieldRACChannelTo(self.viewModel,leftString) =  RACChannelTo(self.leftTextField,text);[RACObserve(self.viewModel,leftString) subscribeNext:^(id  _Nullable x) {    NSLog(@"leftString %@",x);}];[[self.clickButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {    self.viewModel.leftString = @"代码设置StringValue";}];通过RACChannelTo对TextField.txt和VM.leftString进行双向绑定，可以发现，TextField进行键盘输入时，VM.leftString的值不会更新。当通过代码去对VM.leftString进行赋值时，TextField.txt的值更新了。而按照官方的说法就是，UIKIt里面的很多控件本身不支持KVO，而ReactiveCocoa本身是基于KVO实现的，所以就会出现这种双向绑定不成功的现象。  self.valueTextField.rac_newTextChannel : sends values when you type in the text field, but not when you change the text in the text field from code.  RACChannelTo(self.valueTextField, text) : sends values when you change the text in the text field from code, but not when you type in the text field.RACChannelTo(self.viewModel,leftString) = self.leftTextField.rac_newTextChannel;TableViewCell&amp;UITextField#pragma mark - ====================VM层====================@interface TextFieldAndTableCellViewModel : NSObject@property (copy, nonatomic) NSString *leftString;@property (copy, nonatomic) NSString *rightString;@property (strong, nonatomic) NSArray&lt;TextFieldAndTableViewCellViewModel*&gt; *dataArray;@end@implementation TextFieldAndTableCellViewModel-(NSArray *)dataArray{    if (!_dataArray) {        NSMutableArray *tempt = [NSMutableArray array];        for (NSInteger i = 0; i &lt;= 10; i++) {            TextFieldAndTableViewCellViewModel *data = [[TextFieldAndTableViewCellViewModel alloc] init];            data.tag = i;            [tempt addObject:data];        }        _dataArray = [NSArray arrayWithArray:tempt];    }    return _dataArray;}@end#pragma mark - ====================V层====================@interface TextFieldAndTableCellViewController ()&lt;UITableViewDataSource, UITableViewDelegate&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;@property (weak, nonatomic) IBOutlet UITextField *leftTextField;@property (weak, nonatomic) IBOutlet UITextField *rightTextField;@property (weak, nonatomic) IBOutlet UILabel *textLabel;@property (weak, nonatomic) IBOutlet UIButton *clickButton;@property(nonatomic, strong) TextFieldAndTableCellViewModel *viewModel;@end@implementation TextFieldAndTableCellViewController#pragma mark - life cycle- (void)viewDidLoad {    [super viewDidLoad];        [self segInitViews];    [self bindViewModel];    [self.tableView reloadData];}#pragma mark - Init Views-(void)segInitViews{    self.tableView.delegate = self;    self.tableView.dataSource = self;}#pragma mark - Layout- (void)updateViewConstraints {    [super updateViewConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    [[self.clickButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        [self.tableView endEditing:YES];        for (TextFieldAndTableViewCellViewModel *object in self.viewModel.dataArray) {            NSLog(@"inputValue %@",object.inputValue);        }    }];}#pragma mark - getter-(TextFieldAndTableCellViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[TextFieldAndTableCellViewModel alloc]init];    }    return _viewModel;}#pragma mark setter#pragma mark - ====================delegate====================#pragma mark - UITableViewDataSource- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {    return 1;}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {    return self.viewModel.dataArray.count;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {    TextFieldAndTableViewCell *cell = [TextFieldAndTableViewCell cellWithTableView:tableView indexPath:indexPath];    cell.viewModel = self.viewModel.dataArray[indexPath.row];    return cell;}#pragma mark - UITableViewDelegate- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {    return 50;}@end@interface TextFieldAndTableViewCell : UITableViewCell@property (strong, nonatomic) UITextField *inputTextField;@property (strong, nonatomic) NSIndexPath *indexPath;@property(nonatomic,strong) TextFieldAndTableViewCellViewModel* viewModel;+(NSString*)reuseIdentifier;+(TextFieldAndTableViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath;@end@implementation TextFieldAndTableViewCell#pragma mark - Init Views+(NSString*)reuseIdentifier{    return NSStringFromClass([self class]);}+(TextFieldAndTableViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{    TextFieldAndTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier] forIndexPath:indexPath];    if (!cell) {        cell = [[TextFieldAndTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]];    }    cell.indexPath = indexPath;    return cell;}-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{    if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {        [self segInitViews];        [self updateConstraints];    }    return self;}-(void)segInitViews{    [self.contentView addSubview:self.inputTextField];}#pragma mark - Layout- (void)updateConstraints {    [self.inputTextField mas_makeConstraints:^(MASConstraintMaker *make) {        make.left.top.equalTo(self.contentView).mas_offset(5);        make.right.bottom.equalTo(self.contentView).mas_offset(-5);    }];    [super updateConstraints];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    self.inputTextField.text = self.viewModel.inputValue;    self.inputTextField.tag = self.viewModel.tag;        @weakify(self)    [[[[self.inputTextField rac_textSignal] takeUntil:self.rac_prepareForReuseSignal] filter:^BOOL(NSString * _Nullable value) {        NSLog(@"filter -- %@", value);        return YES;    }] subscribeNext:^(NSString * _Nullable x) {        @strongify(self);        NSLog(@"subscribeNext %@ tag:%zd",x,self.inputTextField.tag);        self.viewModel.inputValue = x;    }];}#pragma mark - getter#pragma mark setter-(void)setViewModel:(TextFieldAndTableViewCellViewModel *)viewModel{    _viewModel = viewModel;    if (!viewModel)  return;    [self bindViewModel];}-(UITextField *)inputTextField{    if (!_inputTextField) {        _inputTextField = [[UITextField alloc] init];        _inputTextField.font = [UIFont systemFontOfSize:16];        _inputTextField.textColor = [UIColor blackColor];        _inputTextField.tintColor = [UIColor blackColor];    }    return _inputTextField;}@end@interface TextFieldAndTableViewCellViewModel : NSObject@property (nonatomic, copy) NSString *inputValue;@property (nonatomic, assign) NSInteger tag;@end@implementation TextFieldAndTableViewCellViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {}#pragma mark - getter#pragma mark setter@end示例：登录/*================================================宏================================================*/#define GreenBgColor [UIColor colorWithRed:0.8 green:1.0 blue:0.8 alpha:1]#define RedBgColor   [UIColor colorWithRed:1.0 green:0.8 blue:0.8 alpha:1]#define WhiteBgColor [UIColor whiteColor]#define ConvertInputStateToColor(signal) [InputStateToColorConverter convert:signal]#define ConvertTextToInputState(signal, minimum, maximum) [TextToInputStateConverter convert:signal m##inimum:minimum m##aximum:maximum]typedef enum : NSUInteger {    InputStateEmpty,    InputStateValid,    InputStateInvalid} InputState;/*================================================V层-InputStateToColorConverter================================================*/@interface InputStateToColorConverter : NSObject+ (RACSignal *)convert:(RACSignal *)signal;@end@implementation InputStateToColorConverter+ (RACSignal *)convert:(RACSignal *)signal{    return [signal map:^id(NSNumber *inputStateNumber) {        InputState inputState = [inputStateNumber unsignedIntegerValue];        switch (inputState) {            case InputStateValid:                return GreenBgColor;            case InputStateInvalid:                return RedBgColor;            default:                return WhiteBgColor;        }    }];}@end/*================================================V层-TextToInputStateConverter================================================*/@interface TextToInputStateConverter : NSObject+ (RACSignal *)convert:(RACSignal *)signal minimum:(NSInteger)minimum maximum:(NSInteger)maximum;+ (InputState)inputStateForText:(NSString *)text minimum:(NSInteger)minimum maximum:(NSInteger)maximum;@end@implementation TextToInputStateConverter+ (RACSignal *)convert:(RACSignal *)signal minimum:(NSInteger)minimum maximum:(NSInteger)maximum{    NSAssert(minimum &gt; 0, @"TextToInputStateConverter: minimum must be greater than zero");    NSAssert(maximum &gt;= minimum, @"TextToInputStateConverter: maximum must be greater than or equal to minimum");    return [signal map:^id(NSString *text) {        return @([TextToInputStateConverter inputStateForText:text minimum:minimum maximum:maximum]);    }];}+ (InputState)inputStateForText:(NSString *)text minimum:(NSInteger)minimum maximum:(NSInteger)maximum{    if ([text length] &gt;= minimum &amp;&amp; [text length] &lt;= maximum) {        return InputStateValid;    } else {        if ([text length] == 0) {            return InputStateEmpty;        } else {            return InputStateInvalid;        }    }}@end#pragma mark - ====================VM层====================@interface LoginViewModel : NSObject@property (copy, nonatomic) NSString *usename;@property (copy, nonatomic) NSString *password;@property (nonatomic, assign, readonly) InputState usernameInputState;@property (nonatomic, assign, readonly) InputState passwordInputState;@property (nonatomic, assign, readonly) BOOL loginEnabled;@end@interface LoginViewModel()@property (nonatomic, assign, readwrite) InputState usernameInputState;@property (nonatomic, assign, readwrite) InputState passwordInputState;@property (nonatomic, assign, readwrite) BOOL loginEnabled;@end@implementation LoginViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {    RAC(self,usernameInputState) = ConvertTextToInputState(RACObserve(self,usename), 2, 4);    RAC(self,passwordInputState) = ConvertTextToInputState(RACObserve(self,password), 5, 10);        RAC(self,loginEnabled) = [RACSignal combineLatest:@[RACObserve(self,usernameInputState),RACObserve(self,passwordInputState)] reduce:^id(NSNumber *usernameInputStateValue,NSNumber *passwordInputStateValue){        if ([usernameInputStateValue unsignedIntegerValue] == InputStateValid &amp;&amp;            [passwordInputStateValue unsignedIntegerValue] == InputStateValid) {            return @(YES);        }        return @(NO);    }];}#pragma mark - getter#pragma mark setter@end#pragma mark - ====================V层====================@interface LoginViewController ()@property (weak, nonatomic) IBOutlet UITextField *usenameTextField;@property (weak, nonatomic) IBOutlet UITextField *passwordTextFeidl;@property (weak, nonatomic) IBOutlet UIButton *loginButton;@property(nonatomic, strong) LoginViewModel *viewModel;@end@implementation LoginViewController- (void)viewDidLoad {    [super viewDidLoad];    [self segInitViews];    [self bindViewModel];}#pragma mark - Init Views-(void)segInitViews{}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    // bind input signals    RAC(self.viewModel,usename) = self.usenameTextField.rac_textSignal;    RAC(self.viewModel,password) = self.passwordTextFeidl.rac_textSignal;    // bind output signals    RAC(self.usenameTextField,backgroundColor) = ConvertInputStateToColor(RACObserve(self.viewModel, usernameInputState));    RAC(self.passwordTextFeidl,backgroundColor) = ConvertInputStateToColor(RACObserve(self.viewModel, passwordInputState));    RAC(self.loginButton, enabled) = RACObserve(self.viewModel, loginEnabled);    [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {        NSLog(@"Login....");    }];}#pragma mark - getter-(LoginViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[LoginViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@end示例：豆瓣列表#pragma mark - ====================VM层====================//定义命令、网络请求、获取数据、发送数据@interface DouBanDetailViewModel : NSObject@property (nonatomic, copy, readonly) NSArray&lt;NSString*&gt; *movies;@property (nonatomic, strong, readonly) RACCommand *requestCommand;@property (nonatomic, strong, readonly) AFHTTPSessionManager *manager;@end@implementation DouBanDetailViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        _manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@"https://api.douban.com"]];        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {    @weakify(self)    _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        // 网络请求        RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {            @strongify(self)            [self.manager GET:@"/v2/movie/in_theaters" parameters:input progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {                NSLog(@"sendNext");                [subscriber sendNext:responseObject];                [subscriber sendCompleted];            } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {                [subscriber sendError:error];                NSLog(@"sendError");            }];            return [RACDisposable disposableWithBlock:^{                NSLog(@"disposableWithBlock");            }];        }];        // 业务逻辑处理        return [requestSignal map:^id _Nullable(id  _Nullable value) {            NSLog(@"map");            NSMutableArray *tempt = [NSMutableArray array];            NSMutableArray *dictArray = value[@"subjects"];            for (NSDictionary *object in dictArray) {                [tempt addObject:[object valueForKey:@"title"]];            }            self-&gt;_movies = [NSArray arrayWithArray:tempt];;            return nil;        }];    }];}#pragma mark - getter#pragma mark setter@end#pragma mark - ====================V层====================@interface DouBanViewDetailController ()&lt;UITableViewDataSource,UITableViewDelegate&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;@property(nonatomic, strong) DouBanDetailViewModel *viewModel;@end@implementation DouBanViewDetailController- (void)viewDidLoad {    [super viewDidLoad];    [self segInitViews];    [self bindViewModel];}#pragma mark - Init Views-(void)segInitViews{    self.tableView.delegate = self;    self.tableView.dataSource = self;}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    @weakify(self)    [[[self.viewModel.requestCommand executionSignals] switchToLatest] subscribeNext:^(id  _Nullable x) {        @strongify(self)        NSLog(@"switchToLatest:%@",x);        [self.tableView reloadData];        [SVProgressHUD dismiss];    }];    [self.viewModel.requestCommand.errors subscribeNext:^(NSError * _Nullable x) {        NSLog(@"errors subscribeNext:%@",x);        [SVProgressHUD dismiss];    }];        // 发起网络请求    NSMutableDictionary *parameters = [NSMutableDictionary dictionary];    parameters[@"apikey"] = @"0df993c66c0c636e29ecbb5344252a4a";    [self.viewModel.requestCommand execute:parameters];    [SVProgressHUD show];}// 或者可以这样- (void)bindViewModel {    @weakify(self)    [[self.viewModel.requestCommand executionSignals] subscribeNext:^(RACSignal*  _Nullable x) {        NSLog(@"subscribeNext1:%@",x);        [SVProgressHUD show];        [x subscribeNext:^(id  _Nullable x) {            @strongify(self)            NSLog(@"subscribeNext2:%@",x);            [self.tableView reloadData];            [SVProgressHUD dismiss];        }];    }];        [self.viewModel.requestCommand.errors subscribeNext:^(NSError * _Nullable x) {        NSLog(@"errors subscribeNext:%@",x);        [SVProgressHUD dismiss];    }];    // 发起网络请求    NSMutableDictionary *parameters = [NSMutableDictionary dictionary];    parameters[@"apikey"] = @"0df993c66c0c636e29ecbb5344252a4a";    [self.viewModel.requestCommand execute:parameters];}#pragma mark - UITableViewDataSource- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {    return 1;}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {        return self.viewModel.movies.count;}-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{    return 44.0;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {    DouBanDetailTableViewCell *cell = [DouBanDetailTableViewCell cellWithTableView:tableView indexPath:indexPath];    cell.textLabel.text = self.viewModel.movies[indexPath.row];    return cell;}#pragma mark - getter-(DouBanDetailViewModel *)viewModel{    if (!_viewModel) {        _viewModel = [[DouBanDetailViewModel alloc]init];    }    return _viewModel;}#pragma mark setter@endRACCommand中的sendError没反应的解答  RAC中用RACCommand处理指令// 这样使用就可以捕捉到Error了。[self.viewModel.requestCommand.errors subscribeNext:^(NSError * _Nullable x) {     NSLog(@"errors subscribeNext:%@",x);}];示例:多接口请求@interface DouBanDetailViewModel : NSObject@property (nonatomic, strong, readonly) RACCommand *requestCommand;@end@implementation DouBanDetailViewModel#pragma mark - Init-(instancetype)init{    if (self = [super init]) {        [self racInit];    }    return self;}#pragma mark - business- (void)racInit {    _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        //网络请求1        RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {            NSLog(@"网络请求1");            [subscriber sendNext:@"网络请求1"];            return  nil;        }];                //网络请求2        RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {            NSLog(@"网络请求2");            [subscriber sendNext:@"网络请求2"];            return  nil;        }];                //网络请求3        RACSignal *signal3 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {            NSLog(@"网络请求3");            [subscriber sendNext:@"网络请求3"];            return  nil;        }];                return [self rac_liftSelector:@selector(dealDataWithData1:data2:data3:) withSignalsFromArray:@[signal1,signal2,signal3]];    }];}-(void)dealDataWithData1:(id)data1 data2:(id)data2 data3:(id)data3{}#pragma mark - getter#pragma mark setter@endV层使用：- (void)bindViewModel {    // 发起网络请求    NSMutableDictionary *parameters = [NSMutableDictionary dictionary];    parameters[@"q"] = _conditions;    parameters[@"apikey"] = @"0df993c66c0c636e29ecbb5344252a4a";    [self.viewModel.requestCommand execute:parameters];    [SVProgressHUD show];        [self.viewModel.requestCommand.executionSignals.switchToLatest subscribeNext:^(id  _Nullable x) {        [self.tableView reloadData];        [SVProgressHUD dismiss];    }];    [self.viewModel.requestCommand.executionSignals subscribeError:^(NSError * _Nullable error) {        [SVProgressHUD dismiss];        NSLog(@"subscribeError");    }];    [[[self.viewModel.requestCommand executing] skip:1] subscribeNext:^(NSNumber * _Nullable x) {    }];}示例：RAC、distinctUntilChanged/*==================================VM层======================================*/ @interface RACAndMVVMViewModel01 : NSObject// KVO TextField输入值@property (strong, nonatomic) NSString *searchText;//创建一个绑定View的指令.RACCommand是ReactiveCocoa中呈现UI动作的组件.它包含一个来表示UI动作结果、当前状态、标明动作是否被执行的信号量.@property (strong, nonatomic) RACCommand *executeSearch;@end@implementation RACAndMVVMViewModel01- (instancetype)init {    if (self == [super init]) {        [self checkSearchText];    }    return self;}// 这个方法中将执行一些业务逻辑作为执行命令的结果,并会通过信号异步地返回结果.// 目前只完成了一个虚拟的执行情况;空信号立即完成.延迟操作增加了完成事件返回后的两秒延迟.用来使代码看起来更加真实.- (RACSignal *)executeSearchSignal {    return [[[[RACSignal empty] logAll] delay:2.0] logAll];}// 检查 searchText 输入的合法性-(void)checkSearchText{    /*[[RACObserve(self, searchText) map:^id _Nullable(NSString*  _Nullable value) {     return @(value.length &gt; 3);     }] subscribeNext:^(id  _Nullable x) {     NSLog(@"search text is valid %@", x);     }];*/        // distinctUntilChanged 只有输入合法才能进行打印    RACSignal *validSearchSignal = [[RACObserve(self, searchText) map:^id _Nullable(NSString*  _Nullable value) {        return @(value.length &gt; 3);    }]distinctUntilChanged];    [validSearchSignal subscribeNext:^(id  _Nullable x) {        NSLog(@"search text is valid %@", x);    }];        self.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal signalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        return [self executeSearchSignal];    }];}/*2020-05-29 15:57:23.746708+0800 RACExample[90175:12323634] search text is valid 02020-05-29 15:57:27.843193+0800 RACExample[90175:12323634] search text is valid 12020-05-29 15:57:34.804425+0800 RACExample[90175:12323634] search text is valid 0*/@end/*==================================V层======================================*/ @interface RACAndMVVMViewController01 ()@property (weak, nonatomic) IBOutlet UIButton *loginButton;@property (weak, nonatomic) IBOutlet UITextField *searchTextField;@property (strong, nonatomic) RACAndMVVMViewModel01 *viewModel;@end@implementation RACAndMVVMViewController01- (void)viewDidLoad {    [super viewDidLoad];    [self bindViewModel];}- (void)bindViewModel {    RAC(self.viewModel,searchText) = self.searchTextField.rac_textSignal;    self.loginButton.rac_command = self.viewModel.executeSearch;}-(RACAndMVVMViewModel01 *)viewModel{    if (!_viewModel) {        _viewModel = [[RACAndMVVMViewModel01 alloc] init];    }    return _viewModel;}当按钮值为Input时，按钮的状态是Disabled，因为输入的内容不合法。示例：发邮件#pragma mark - ====================VM层====================@interface RACAndMVVMViewModel02 : NSObject@property(nonatomic, strong) NSString *email;@property(nonatomic, strong) NSString *statusMessage;@property(nonatomic, strong) RACCommand *subscribeCommand;@end@implementation RACAndMVVMViewModel02-(instancetype)init{    if (self == [super init]) {        [self rac_init];    }    return self;}-(void)rac_init{    @weakify(self)    RACSignal *emailSignal = [[RACObserve(self, email) map:^id _Nullable(NSString*  _Nullable value) {        @strongify(self)        return @([self isValidEmail:value]);    }]distinctUntilChanged];        [emailSignal subscribeNext:^(id  _Nullable x) {        NSLog(@"%@",x);    }];        self.subscribeCommand = [[RACCommand alloc] initWithEnabled:emailSignal signalBlock:^RACSignal * _Nonnull(id  _Nullable input) {        @strongify(self)        return [self businessOperation:self.email];    }];        RACSignal *rac1 = [self.subscribeCommand.executionSignals map:^id _Nullable(id  _Nullable value) {        NSLog(@"Request");        return @"Request";    }];    RACSignal *rac2 = [self.subscribeCommand.executionSignals flattenMap:^__kindof RACSignal * _Nullable(RACSignal* signal) {        return [[[signal materialize]filter:^BOOL(RACEvent *event) {            NSLog(@"... RACEventType:%zd",event.eventType);            return event.eventType == RACEventTypeCompleted;        }] map:^id _Nullable(id  _Nullable value) {            NSLog(@"Thanks!");            return @"Thanks!";        }];    }];    RACSignal *rac3 = [[self.subscribeCommand.errors subscribeOn:[RACScheduler mainThreadScheduler]] map:^id _Nullable(NSError * _Nullable value) {        NSLog(@"Error");        return @"Error";    }];    RAC(self,statusMessage) = [RACSignal merge:@[rac1,rac2,rac3]];}// 处理业务逻辑-(RACSignal*)businessOperation:(NSString*)content{    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {        NSLog(@"Loading...");        [subscriber sendNext:@"Loading..."];        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{            [subscriber sendError:nil];        });        return [RACDisposable disposableWithBlock:^{        }];    }];}// 检测strin是否是邮件- (BOOL)isValidEmail:(NSString*)content {    if (!content) return NO;        NSString *emailPattern =    @"(?:[a-z0-9!#$%\\&amp;'*+/=?\\^_`{|}~-]+(?:\\.[a-z0-9!#$%\\&amp;'*+/=?\\^_`{|}"    @"~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\"    @"x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-"    @"z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5"    @"]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-"    @"9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21"    @"-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])";    NSError *error = nil;    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:emailPattern options:NSRegularExpressionCaseInsensitive error:&amp;error];    NSTextCheckingResult *match = [regex firstMatchInString:content options:0 range:NSMakeRange(0, [content length])];    return match != nil;}@end#pragma mark - ====================V层====================@interface RACAndMVVMViewController02 ()@property (weak, nonatomic) IBOutlet UITextField *inputTextField;@property (weak, nonatomic) IBOutlet UIButton *loginButton;@property (weak, nonatomic) IBOutlet UILabel *statusLabel;@property(nonatomic, strong) RACAndMVVMViewModel02 *viewModel;@end@implementation RACAndMVVMViewController02- (void)viewDidLoad {    [super viewDidLoad];    [self bindViewModel];}#pragma mark - Private Methods#pragma mark - RAC Data Binding- (void)bindViewModel {    RAC(self.viewModel,email) = self.inputTextField.rac_textSignal;    RAC(self.statusLabel,text) = RACObserve(self.viewModel, statusMessage);    self.loginButton.rac_command = self.viewModel.subscribeCommand;}#pragma mark - getter-(RACAndMVVMViewModel02 *)viewModel{    if (!_viewModel) {        _viewModel = [RACAndMVVMViewModel02 new];    }    return _viewModel;}#pragma mark setter@end/*2020-05-29 16:58:36.155235+0800 RACExample[92708:12365862] 02020-05-29 16:58:40.675972+0800 RACExample[92708:12365862] 12020-05-29 16:58:43.872743+0800 RACExample[92708:12365862] Request2020-05-29 16:58:43.873233+0800 RACExample[92708:12365862] Loading...2020-05-29 16:58:43.873464+0800 RACExample[92708:12365862] ... RACEventType:2 --&gt; 0 = RACEventTypeNext2020-05-29 16:58:45.874203+0800 RACExample[92708:12365862] ... RACEventType:0 --&gt; 0 = RACEventTypeCompleted2020-05-29 16:58:45.874431+0800 RACExample[92708:12365862] Thanks!2020-05-29 16:58:45.876062+0800 RACExample[92708:12365862] Error*/ 资料  Github-ReactiveCocoa  响应式编程（Reactive Programming）介绍  UITextField-RAC使用详解  iOS使用RAC实现MVVM的正经姿势  优雅的 RACCommandhttp://timmy6.github.io/2019/02/27/MVVM/]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tree命令使用记录]]></title>
      <url>/diary/2020/05/25/diary-tree/</url>
      <content type="text"><![CDATA[官方文档：usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ]	[-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version]	[--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst]	[--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;]	[--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--fromfile] [--]	[&lt;directory list&gt;]  ------- Listing options -------  -a            All files are listed.  -d            List directories only.  -l            Follow symbolic links like directories.  -f            Print the full path prefix for each file.  -x            Stay on current filesystem only.  -L level      Descend only level directories deep.  -R            Rerun tree when max dir level reached.  -P pattern    List only those files that match the pattern given.  -I pattern    Do not list files that match the given pattern.  --ignore-case Ignore case when pattern matching.  --matchdirs   Include directory names in -P pattern matching.  --noreport    Turn off file/directory count at end of tree listing.  --charset X   Use charset X for terminal/HTML and indentation line output.  --filelimit # Do not descend dirs with more than # files in them.  --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;.  -o filename   Output to file instead of stdout.  ------- File options -------  -q            Print non-printable characters as '?'.  -N            Print non-printable characters as is.  -Q            Quote filenames with double quotes.  -p            Print the protections for each file.  -u            Displays file owner or UID number.  -g            Displays file group owner or GID number.  -s            Print the size in bytes of each file.  -h            Print the size in a more human readable way.  --si          Like -h, but use in SI units (powers of 1000).  -D            Print the date of last modification or (-c) status change.  -F            Appends '/', '=', '*', '@', '|' or '&gt;' as per ls -F.  --inodes      Print inode number of each file.  --device      Print device ID number to which each file belongs.  ------- Sorting options -------  -v            Sort files alphanumerically by version.  -t            Sort files by last modification time.  -c            Sort files by last status change time.  -U            Leave files unsorted.  -r            Reverse the order of the sort.  --dirsfirst   List directories before files (-U disables).  --sort X      Select sort: name,version,size,mtime,ctime.  ------- Graphics options -------  -i            Don't print indentation lines.  -A            Print ANSI lines graphic indentation lines.  -S            Print with CP437 (console) graphics indentation lines.  -n            Turn colorization off always (-C overrides).  -C            Turn colorization on always.  ------- XML/HTML/JSON options -------  -X            Prints out an XML representation of the tree.  -J            Prints out an JSON representation of the tree.  -H baseHREF   Prints out HTML format with baseHREF as top directory.  -T string     Replace the default HTML title and H1 header with string.  --nolinks     Turn off hyperlinks in HTML output.  ------- Input options -------  --fromfile    Reads paths from files (.=stdin)  ------- Miscellaneous options -------  --version     Print version and exit.  --help        Print usage and this help message and exit.  --            Options processing terminator.# 过滤单文件夹tree -I "node_modules"# 过滤多文件夹tree -I "node_modules|cache|test_*"# 显示文件相对路径tree -f# n表示显示项目的层级，n=3即只显示项目的三层结构 tree -L 2 只显示2层tree -L n# 在文件和目录清单加上色彩，便于区分各种类型。tree -C# 显示目录名称而非内容tree -d# 限制目录显示层级tree -p# 结果输出为txt文档tree &gt; 1.txt]]></content>
      <categories>
        
          <category> diary </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Cocopods使用笔记]]></title>
      <url>/diary/2020/05/25/diary-cocopods/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> diary </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iPhone界面适配]]></title>
      <url>/ios/2020/04/02/ios-iphone-size/</url>
      <content type="text"><![CDATA[机型展示图示  表格标题带颜色表明该机型是齐刘海导航栏。            iPhone11Pro      iPhone11ProMax      iPhone11      iPhoneXS                                                      iPhoneXSMax      iPhoneXR      iPhoneX      iPhone8Plus                                                      iPhone8      iPhone7Plus      iPhone7      iPhone6sPlus                                                      iPhone6s      iPhone6Plus      iPhone6      iPhoneSE                                          机型展示数据            机型      屏幕尺寸(inch)      物理分辨率(pixel)      逻辑分辨率(point)      缩放因子      屏幕密度(ppi)      Status高度      Navi高度      Tab高度      底部安全距离                  11 Pro      5.8      1125*2436      375*812      @3x      458      44      44      83      34              XS      5.8      1125*2436      375*812      @3x      458      44      44      83      34              X      5.8      1125*2436      375*812      @3x      458      44      44      83      34              11 Pro Max      6.5      1242*2688      414*896      @3x      458      44      44      83      34              XS Max      6.5      1242*2688      414*896      @3x      458      44      44      83      34              11      6.1      828*1792      414*896      @2x      326      44      44      83      34              XR      6.1      828*1792      414*896      @2x      326      44      44      83      34              8 Plus      5.5      1080*19201242*2208      414*736      @3x      401      20      44      49      -              7 Plus      5.5      1080*19201242*2208      414*736      @3x      401      20      44      49      -              6s Plus      5.5      1080*19201242*2208      414*736      @3x      401      20      44      49      -              6 Plus      5.5      1080*19201242*2208      414*736      @3x      401      20      44      49      -              8      4.7      750*1334      375*667      @2x      326      20      44      49      -              7      4.7      750*1334      375*667      @2x      326      20      44      49      -              6s      4.7      750*1334      375*667      @2x      326      20      44      49      -              6      4.7      750*1334      375*667      @2x      326      20      44      49      -              SE      4      640*1136      320*568      @2x      326      20      44      49      -      1inch = 2.54cm = 25.4mm1pt = 2px屏幕密度(Pixel Per Inch by diagonal):沿着对角线每英寸所拥有放入像素总数。例如iPhone6的PPI：326，屏幕尺寸为：4.7，物理分辨率：750*1334。代码适配// ???self.extendedLayoutIncludesOpaqueBars = YES;// ???@property(nonatomic) UIScrollViewContentInsetAdjustmentBehavior contentInsetAdjustmentBehavior API_AVAILABLE(ios(11.0),tvos(11.0));齐刘海适配safeAreaLayoutGuideTODOiPhone11、iPhoneXR为什么是@2x？屏幕密度(ppi)为326使用@2x,比之大的用@3x。  iPhone8Plus、iPhone7Plus、iPhone6sPlus 为什么要将@3x渲染的2208*1242分辨率缩小到1080*1920屏幕上？  缩放因子的计算方式？参考资料  iOS所有设备的分辨率、尺寸和缩放因子，放大模式区别和6P实际分辨率  苹果手机各种尺寸详细表以及iPhoneX、iPhoneXS、iPhoneXR、iPhoneXSMax、iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max、屏幕适配  为什么 iPhone 6 Plus 要将 3x 渲染的 2208x1242 分辨率缩小到 1080p 屏幕上？  iPhone Plus手机的分辨率到底是多少，是1080×1920还是1242×2208？  IOS设计尺寸规范  iPhoneX页面安全区域与内容重叠问题  The iPhone wiki-Model  关于iOS 11 SafeArea 总结]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS中__attribute__]]></title>
      <url>/ios/2020/03/13/ios-attribute/</url>
      <content type="text"><![CDATA[__attribute__是一个编译器指令，方便开法则向编译器表达某种要求，一般为了方便使用会被定义成宏。像系统库中NS_AVAILABLE_IOS(5_0)。GCCGCC环境下提供可以使用的编译属性。formatformat属性指定一个函数具有printf，scanf，strftime或者strfmon根据格式字符串类型的参数，是对于数据类型的检查。在OC中使用__NSString__具有相同的效果。FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;在系统库的NSLog方法定义中，NS_FORMAT_FUNCTION(1,2) 宏定义的意思是：NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))nonnullnonnull属性指定某些函数参数应为非空指针。extern void * testFunc(void *var1, const void *var2) __attribute__((nonnull(1,2)));unusedpure / constnoreturnnoreturn：这个属性告诉编译器函数不会返回，这可以用来抑制关于未达到代码路径的错误。// stdlib.hvoid abort(void) __attribute__((noreturn));void exit(int) __attribute__((noreturn));        AFNetworking 将该noreturn属性用于其网络请求线程入口点方法visibility__attribute__((visibility("default")))  //默认，设置为：default之后就可以让外面的类看见了。__attribute__((visibility("hideen")))  //隐藏LLVMconstructor / destructor  constructor / destructor：构造器(constructor)和析构器(destructor)，加上这两个属性的函数会在分别在可执行文件（或 shared library）load 和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行//main.m__attribute__((constructor))static void beforeMain(void){NSLog(@"beforeMain");}__attribute__((destructor))static void afterMain(void){NSLog(@"afterMain");}int main(int argc, char * argv[]) {    @autoreleasepool {        NSLog(@"main");        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));    }}//ViewController01.m#import "ViewController01.h"__attribute__((constructor))static void beforeMain(void){NSLog(@"ViewController01-beforeMain");}__attribute__((destructor))static void afterMain(void){NSLog(@"ViewController01-afterMain");}@implementation ViewController01+(void)load{    NSLog(@"ViewController01-load");}@end// ===&gt; 从应用启动到消失// 2019-08-07 17:09:33.320935+0800 RACDemo01[97014:1447204] ViewController01-load// 2019-08-07 17:09:33.321707+0800 RACDemo01[97014:1447204] ViewController01-beforeMain// 2019-08-07 17:09:33.322068+0800 RACDemo01[97014:1447204] beforeMain// 2019-08-07 17:09:33.322225+0800 RACDemo01[97014:1447204] main// 2019-08-07 17:09:52.370147+0800 RACDemo01[97014:1447204] afterMain// 2019-08-07 17:09:52.370427+0800 RACDemo01[97014:1447204] ViewController01-afterMain  constructor和+load方法都是在main函数执行前调用,但 +load 比 constructor 更加早一点，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类， 每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。优点  因为它的生命周期是：所有 Class 都已经加载完成，main 函数还未执行，可以做一些自定义的操作。  constructor 无需像 +load 还得挂载在一个 Class 中。  constructor 在多个的情况下，可以设置优先级：__attribute__((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留objc_boxable  objc_boxable：Objective-C 中的 @(...) 语法糖可以将基本数据类型 box 成 NSNumber 对象typedef struct __attribute__((objc_boxable)) {    CGFloat x, y, width, height;} XXRect;// CGRect rect1 = {1, 2, 3, 4};// NSValue *value1 = @(rect1); // &lt;--- Compile Error// XXRect rect2 = {1, 2, 3, 4};// NSValue *value2 = @(rect2); // √overloadable  overloadable：Clang在C中提供对C++函数重载的支持overloadable。修改过以后就可以实现 重载的功能：deprecated  deprecated：在编译时会报过时警告availabilityavailability：使用版本、平台情况及相关说明信息  introduced：引进的版本  deprecated：废弃的版本，还能使用，并没有移除，而是提醒用户迁移到其他API  obsoleted：移除的版本，不能再使用  unavailable：那些平台不能用  message：额外提示信息，比如迁移到某某API支持的平台：  ios：Apple的iOS操作系统。  macosx：Apple的OS X操作系统。方法-(void)testFunction1 __attribute__((availability(ios,introduced=2_0,deprecated=4_0,obsoleted=11_0,message="这是个测试信息")));-(void)testFunction2 NS_CLASS_DEPRECATED_IOS(2_0,9_0,"这是个测试信息"); // NS_CLASS_DEPRECATED_IOS 这是系统定义的。类__attribute__((availability(ios,introduced=2_0,deprecated=4_0,obsoleted=11_0,message="这是个测试信息")))@interface ViewController01 : UIViewController@end// 或者NS_CLASS_DEPRECATED_IOS(2_0,9_0,"这是个测试信息")@interface ViewController01 : UIViewController@endunavailable// 定义在ios平台不能用,强制使用会报错-(void)testFunction1 __attribute__((availability(ios,unavailable,message="这是个测试信息")));//或者-(void)testFunction1 NS_UNAVAILABLE;unavailable  unavailable：告诉编译器某方法不可用，如果强行调用编译器会提示错误@property (strong,nonatomic) id var1 NS_UNAVAILABLE;-(void)testFunction1 __attribute__((unavailable("这是个测试信息")));nonnull  nonnull：编译器对函数参数进行检查，不能为null，参数类型必须为指针类型（包括对象）从上面的方法可以看出，nonnull必须为指针类型，所以优化结果：-(void)testFunctionWithPara1:(NSString*)para1 para2:(NSString*)para2 para3:(NSInteger)para3 __attribute__((nonnull(1,2)));objc_root_class  objc_root_class：表示这个类是一个基类NSObject就是通过OBJC_ROOT_CLASS来设置为基类的。OBJC_ROOT_CLASS@interface NSObject &lt;NSObject&gt; {}@endOBJC_ROOT_CLASS#if !defined(OBJC_ROOT_CLASS)#   if __has_attribute(objc_root_class)#       define OBJC_ROOT_CLASS __attribute__((objc_root_class))#   else#       define OBJC_ROOT_CLASS#   endif#endifobjc_designated_initializer  objc_designated_initializer：指定类的初始化方法，并不是对使用者，而是对类内部的实现  规则：如果该类有objc_designated_initializer的初始化方法，那么它必须覆盖实现父类的objc_designated_initializer方法objc_requires_super  objc_requires_super：表示子类在重写父类的方法的时候，必须先调用super方法，否则会有警告objc_subclassing_restricted  objc_subclassing_restricted：表示该类不能被继objc_runtime_name  objc_runtime_name：用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个。__attribute__((objc_runtime_name("SarkGay")))@interface Sark : NSObject@endNSLog(@"%@", NSStringFromClass([Sark class])); // "SarkGay"最直接的用处就是进行代码混淆：__attribute__((objc_runtime_name("40ea43d7629d01e4b8d6289a132482d0dd5df4fa")))@interface SecretClass : NSObject@end/ @singleton 包裹了 __attribute__((objc_runtime_name(...)))// 将类名改名成 "SINGLETON_Sark_sharedInstance"@singleton(Sark, sharedInstance)@interface Sark : NSObject+ (instancetype)sharedInstance;@end在运行时用 __attribute__((constructor)) 获取入口时机，用 runtime 找到这个类，反解出 sharedInstance 这个 selector 信息，动态将 + alloc，- init 等方法替换，返回 + sharedInstance 单例。warn_unused_result  warn_unused_result 如果方法定义有返回值，调用的时候没有定义变量进行承接，就会显示警告cleanup__attribute__((cleanup(...)))：用于修饰一个变量(基础变量、系统对象类型、自定义Class类型)，在它的作用域结束(包括大括号结束、return、goto、break、exception等各种情况)时可以自动执行一个指定的方法。// 系统对象类型// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配static void stringCleanUp(__strong NSString **string) {    NSLog(@"%@", *string);}// 在某个方法中：{    __strong NSString *string __attribute__((cleanup(stringCleanUp))) = @"sunnyxx";} // 当运行到这个作用域结束时，自动调用stringCleanUp// 自定义的Classstatic void sarkCleanUp(__strong Sark **sark) {    NSLog(@"%@", *sark);}__strong Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];// 基本类型static void intCleanUp(NSInteger *integer) {    NSLog(@"%d", *integer);}NSInteger integer __attribute__((cleanup(intCleanUp))) = 1;  cleanup：用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法  黑魔法__attribute__((cleanup))使用blockstatic void blockCleanUp(__strong void(^*block)(void)) {    (*block)();}- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // 加了个`unused`的attribute用来消除`unused variable`的warning    __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^{        NSLog(@"I'm dying...");    };    // ... 很多代码    return YES;}I'm dying... 这句话会在didFinishLaunchingWithOptions方法执行完以后输出。将一段写在前面的代码最后执行可以将成对出现的代码写在一起，比如说一个lock：NSRecursiveLock *aLock = [[NSRecursiveLock alloc] init];[aLock lock];// 这里有100多万行[aLock unlock]; // 看到这儿的时候早忘了和哪个lock对应着了参考资料  attribute  attribute 总结  Clang Attributes 黑魔法小记  Clang 3.8 documentation]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ruby使用记录]]></title>
      <url>/diary/2020/03/09/diary-ruby/</url>
      <content type="text"><![CDATA[安装Brew因为重新安装Ruby会依赖于Brew，所以我们先安装Brew环境,Brew官网。# 根据官方的地址，安装环境$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"# 如果执行上面的命令失败，可以把：https://raw.githubusercontent.com/Homebrew/install/master/install.sh 保存到本地为：install.sh$ sh install.sh# 如果报如下错误：Already downloaded: /Users/shanliu/Library/Caches/Homebrew/portable-ruby-2.6.3.mavericks.bottle.tar.gzError: Checksum mismatch.Expected: ab81211a2052ccaa6d050741c433b728d0641523d8742eef23a5b450811e5104  Actual: bce400586f4c3130c46db9519de5b636f089134c7999dc665108979509a41234 Archive: /Users/shanliu/Library/Caches/Homebrew/portable-ruby-2.6.3.mavericks.bottle.tar.gzTo retry an incomplete download, remove the file above.Error: Failed to install vendor Ruby.# 删除：/Users/shanliu/Library/Caches/Homebrew/portable-ruby-2.6.3.mavericks.bottle.tar.gz# 重新执行Shell脚本更换Brew为国内(中科大源)镜像$ git clone git://mirrors.ustc.edu.cn/homebrew-core.git /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1$ git clone git://mirrors.ustc.edu.cn/homebrew-cask.git /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask --depth=1$ cd /usr/local/Homebrew$ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git$ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git$ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git# 更换完镜像后看看有没有问题$ brew update$ brew doctor如果想要切回原镜像$ cd /usr/local/Homebrew$ git remote set-url origin https://github.com/Homebrew/brew.git$ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core$ git remote set-url origin https://github.com/Homebrew/homebrew-core.git# 更换完镜像后看看有没有问题$ brew update$ brew doctorRuby卸载、重新安装# 查看ruby版本$ ruby -vruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin17]# 移除当前版本的ruby$ rvm uninstall 2.4.1p111# 彻底移除$ rvm remove 2.4.1p111# 查看当前ruby的最新版本$ rvm list known# MRI Rubies[ruby-]1.8.6[-p420][ruby-]1.8.7[-head] # security released on head[ruby-]1.9.1[-p431][ruby-]1.9.2[-p330][ruby-]1.9.3[-p551][ruby-]2.0.0[-p648][ruby-]2.1[.10][ruby-]2.2[.10][ruby-]2.3[.7][ruby-]2.4[.4][ruby-]2.5[.1][ruby-]2.6[.0-preview2]ruby-head# for forks use: rvm install ruby-head-&lt;name&gt; --url https://github.com/github/ruby.git --branch 2.2# JRubyjruby-1.6[.8]jruby-1.7[.27]jruby-9.1[.17.0]jruby[-9.2.0.0]jruby-head# Rubiniusrbx-1[.4.3]rbx-2.3[.0]rbx-2.4[.1]rbx-2[.5.8]rbx-3[.100]rbx-head# TruffleRubytruffleruby[-1.0.0-rc2]# Opalopal# Minimalistic ruby implementation - ISO 30170:2012mruby-1.0.0mruby-1.1.0mruby-1.2.0mruby-1.3.0mruby-1[.4.0]mruby[-head]# Ruby Enterprise Editionree-1.8.6ree[-1.8.7][-2012.02]# Topaztopaz# MagLevmaglev-1.0.0maglev-1.1[RC1]maglev[-1.2Alpha4]maglev-head# Mac OS X Snow Leopard Or Newermacruby-0.10macruby-0.11macruby[-0.12]macruby-nightlymacruby-head# IronRubyironruby[-1.1.3]ironruby-head# 安装$ rvm install 2.5 --disable-binaryChecking requirements for osx.Installing requirements for osx.Updating system............Installing required packages: autoconf, automake, libtool, pkg-config, coreutils, libyaml, readline, libksba, openssl@1.1..-............Certificates bundle '/usr/local/etc/openssl@1.1/cert.pem' is already up to date.Requirements installation successful.Installing Ruby from source to: /Users/shanliu/.rvm/rubies/ruby-2.5.1, this may take a while depending on your cpu(s)...ruby-2.5.1 - #downloading ruby-2.5.1, this may take a while depending on your connection...  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100 13.3M  100 13.3M    0     0  1751k      0  0:00:07  0:00:07 --:--:-- 2922kruby-2.5.1 - #extracting ruby-2.5.1 to /Users/shanliu/.rvm/src/ruby-2.5.1.....ruby-2.5.1 - #configuring...................................................................ruby-2.5.1 - #post-configuration.ruby-2.5.1 - #compiling...............................................................ruby-2.5.1 - #installing.........ruby-2.5.1 - #making binaries executable..ruby-2.5.1 - #downloading rubygems-2.7.10  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  843k  100  843k    0     0   5247      0  0:02:44  0:02:44 --:--:-- 10129No checksum for downloaded archive, recording checksum in user configuration.ruby-2.5.1 - #extracting rubygems-2.7.10.....ruby-2.5.1 - #removing old rubygems........ruby-2.5.1 - #installing rubygems-2.7.10.....................................ruby-2.5.1 - #gemset created /Users/shanliu/.rvm/gems/ruby-2.5.1@globalruby-2.5.1 - #importing gemset /Users/shanliu/.rvm/gemsets/global.gems...................................................ruby-2.5.1 - #generating global wrappers.......ruby-2.5.1 - #gemset created /Users/shanliu/.rvm/gems/ruby-2.5.1ruby-2.5.1 - #importing gemsetfile /Users/shanliu/.rvm/gemsets/default.gems evaluated to empty gem listruby-2.5.1 - #generating default wrappers.......ruby-2.5.1 - #adjusting #shebangs for (gem irb erb ri rdoc testrb rake).Install of ruby-2.5.1 - #complete Ruby was built without documentation, to build it run: rvm docs generate-ri# 查看版本$ ruby -vruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin18]其他用法# 查询已经安装的 ruby$ rvm list# 切换 Ruby 版本$ rvm use 2.2.0# 设置默认版本rvm use 2.2.0 --default# 如果之前安装过 RVM 想要更新 $ rvm get stable报错日志记录$ rvm install 2.5 --disable-binaryChecking requirements for osx.About to install Homebrew, press `Enter` for default installation in `/usr/local`,type new path if you wish custom Homebrew installation (the path needs to be writable for user)# 如果中间停顿，则是 要授权 输入  yes 即可，初次安装要等好久，切记要耐心!: yes  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   124  100   124    0     0     34      0  0:00:03  0:00:03 --:--:--    34100   139  100   139    0     0     32      0  0:00:04  0:00:04 --:--:--  135k100   416    0   416    0     0     68      0 --:--:--  0:00:06 --:--:--   512chmod: yes/bin/brew: No such file or directorySomething went wrong during Homebrew installation,can not find 'brew' command, please report a bug: https://bit.ly/rvm-issuesRequirements installation failed with status: 1.  需要安装brew环境。学习指南  Ruby Koans:可以指引你走过学习 Ruby 的启蒙之路。在这里可以学到 Ruby 语言的语法、结构、常用函数和库。当然，还有 Ruby 文化。  Ruby 程序员最好的朋友  Ruby 参考教程  最新最全Ruby、Ruby on Rails精品电子书等学习资料下载参考资料  brew  Mac必备神器Homebrew  《Ruby编程语言》  《Ruby元编程》  《Programming Ruby》-大卫.托马斯]]></content>
      <categories>
        
          <category> diary </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WKWebView网页组件]]></title>
      <url>/ios/2020/03/03/ios-wkwebview/</url>
      <content type="text"><![CDATA[WebKit组件部分属性方法WKWebView@property (nullable, nonatomic, weak) id &lt;WKNavigationDelegate&gt; navigationDelegate; // 导航代理@property (nullable, nonatomic, weak) id &lt;WKUIDelegate&gt; UIDelegate;// UI代理@property (nullable, nonatomic, readonly, copy) NSString *title;// 页面标题, 一般使用KVO动态获取@property (nonatomic, readonly) double estimatedProgress;// 页面加载进度, 一般使用KVO动态获取@property (nonatomic, readonly, strong) WKBackForwardList *backForwardList;// 可返回的页面列表@property (nullable, nonatomic, readonly, copy) NSURL *URL;// 页面url@property (nonatomic, readonly, getter=isLoading) BOOL loading;// 页面是否在加载中@property (nonatomic, readonly) BOOL canGoBack;// 是否可返回@property (nonatomic, readonly) BOOL canGoForward;// 是否可向前@property (nonatomic, readonly, strong) UIScrollView *scrollView;@property (nonatomic) BOOL allowsBackForwardNavigationGestures;// 是否允许手势左滑//自定义UserAgent, 会覆盖默认的值 ,iOS 9之后有效@property (nullable, nonatomic, copy) NSString *customUserAgent部分的方法：// 带配置信息的初始化方法// configuration 配置信息- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration// 加载请求- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;// 加载HTML- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;// 返回上一级- (nullable WKNavigation *)goBack;// 前进下一级, 需要曾经打开过, 才能前进- (nullable WKNavigation *)goForward;// 刷新页面- (nullable WKNavigation *)reload;// 根据缓存有效期来刷新页面- (nullable WKNavigation *)reloadFromOrigin;// 停止加载页面- (void)stopLoading;// 执行JavaScript代码- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler;WKWebViewConfiguration初始化WKWebView的配置属性，这是个属性的集合。@property (nonatomic, strong) WKProcessPool *processPool;//  首选项设置:可设置最小字号、是否通过js自动打开新的窗口@property (nonatomic, strong) WKPreferences *preferences;// 通过此属性来执行JavaScript代码来修改页面的行为@property (nonatomic, strong) WKUserContentController *userContentController;@property (nonatomic, strong) WKWebsiteDataStore *websiteDataStore API_AVAILABLE(ios(9.0));// 是使用h5的视频播放器在线播放(YES), 还是使用原生播放器全屏播放(NO),默认值：NO@property (nonatomic) BOOL allowsInlineMediaPlayback;// 设置视频是否需要用户手动播放  设置为NO则会允许自动播放。@property (nonatomic) BOOL requiresUserActionForMediaPlayback API_DEPRECATED_WITH_REPLACEMENT("mediaTypesRequiringUserActionForPlayback", ios(9.0, 10.0));//设置是否允许画中画技术 在特定设备上有效，默人YES。@property (nonatomic) BOOL allowsPictureInPictureMediaPlayback API_AVAILABLE(ios(9_0));// 设置请求的User-Agent信息中应用程序名称@property (nullable, nonatomic, copy) NSString *applicationNameForUserAgent API_AVAILABLE(ios(9.0));WKUseWKUserContentController可以通过WKUserContentController实现与JavaScript的交互。// 注入JavaScript与原生交互协议// JS 端可通过 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 发送消息- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;// 移除注入的协议, 在deinit方法中调用- (void)removeScriptMessageHandlerForName:(NSString *)name;// 通过WKUserScript注入需要执行的JavaScript代码- (void)addUserScript:(WKUserScript *)userScript;// 移除所有注入的JavaScript代码- (void)removeAllUserScripts;- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;通过WKScriptMessageHandler协议, 获取JavaScript端传递的事件和参数：- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;其中WKScriptMessage中含有的协议名称及参数：@property (nonatomic, readonly, copy) NSString *name;// 协议名称, 即上面的add方法传递的name@property (nonatomic, readonly, copy) id body;// 传递的参数WKPreferences这是首选项配置类，一般在WKWebViewConfiguration里面设置。// 最小字体大小 当将javaScriptEnabled属性设置为NO时，可以看到明显的效果@property (nonatomic) CGFloat minimumFontSize;// 设置是否支持javaScript 默认是支持的@property (nonatomic) BOOL javaScriptEnabled;// 在iOS上默认为NO，表示是否允许不经过用户交互由javaScript自动打开窗口@property (nonatomic) BOOL javaScriptCanOpenWindowsAutomatically;WKBackForwardList可返回的页面列表, 存储已打开过的网页。WKUserScript主要是需要加载的页面中添加一些额外执行的JavaScript代码，这是个初始化方法；一般是搭配WKWebViewConfiguration使用。/*source: 需要执行的JavaScript代码injectionTime: 加入的位置, 是一个枚举typedef NS_ENUM(NSInteger, WKUserScriptInjectionTime) {    WKUserScriptInjectionTimeAtDocumentStart,    WKUserScriptInjectionTimeAtDocumentEnd} API_AVAILABLE(macosx(10.10), ios(8.0));forMainFrameOnly: 是加入所有框架, 还是只加入主框架*/- (instancetype)initWithSource:(NSString *)source injectionTime:(WKUserScriptInjectionTime)injectionTime forMainFrameOnly:(BOOL)forMainFrameOnly;WKUIDelegate主要处理JS脚本，确认框，警告框等。// web界面中有弹出警告框时调用,JS中调用alert方法- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Title" message:message?:@"" preferredStyle:UIAlertControllerStyleAlert];    [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {        completionHandler();    }])];    [self presentViewController:alertController animated:YES completion:nil];}// web界面中有确认框时调用,JS中调用confirm方法- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler{    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"" message:message?:@"" preferredStyle:UIAlertControllerStyleAlert];    [alertController addAction:([UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {        completionHandler(NO);    }])];    [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {        completionHandler(YES);    }])];    [self presentViewController:alertController animated:YES completion:nil];}// web界面中有输入框时调用,JS中调用prompt方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler{    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:prompt message:@"" preferredStyle:UIAlertControllerStyleAlert];    [alertController addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {        textField.text = defaultText;    }];    [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {        completionHandler(alertController.textFields[0].text?:@"");    }])];    [self presentViewController:alertController animated:YES completion:nil];}            alert      confirm      prompt                                            alert("被OC截获到了");      confirm("被OC截获到了");      prompt("A","B");      WKNavigationDelegateWKNavigationDelegate主要用于处理一些跳转、加载处理操作。// 页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation {}// 页面加载失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error {    [self.progressView setProgress:0.0f animated:NO];} // 当内容开始返回时调用- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {}// 页面加载完成之后调用- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {}//提交发生错误时调用- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error {    [self.progressView setProgress:0.0f animated:NO];}  // 接收到服务器跳转请求即服务重定向时之后调用- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation {}// 根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {    // iTunes: App Store link    if ([urlString isMatch:RX(@"\\/\\/itunes\\.apple\\.com\\/")]) {        [[UIApplication sharedApplication] openURL:url];        decisionHandler(WKNavigationActionPolicyCancel);        return;    }    decisionHandler(WKNavigationActionPolicyAllow);}// 根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{    NSString * urlStr = navigationResponse.response.URL.absoluteString;    NSLog(@"当前跳转地址：%@",urlStr);    //允许跳转    decisionHandler(WKNavigationResponsePolicyAllow);    //不允许跳转    //decisionHandler(WKNavigationResponsePolicyCancel);} // 用于授权验证- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler{    //用户身份信息    NSURLCredential * newCred = [[NSURLCredential alloc] initWithUser:@"user123" password:@"123" persistence:NSURLCredentialPersistenceNone];    //为 challenge 的发送方提供 credential    [challenge.sender useCredential:newCred forAuthenticationChallenge:challenge];    completionHandler(NSURLSessionAuthChallengeUseCredential,newCred);}//进程被终止时调用- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView{}WKHTTPCookieStoreWKWebView自己管理cookie的工具。// 查找所有已存储的cookie- (void)getAllCookies:(void (^)(NSArray&lt;NSHTTPCookie *&gt; *))completionHandler;// 保存一个cookie, 保存成功后, 会走一次回调方法- (void)setCookie:(NSHTTPCookie *)cookie completionHandler:(nullable void (^)(void))completionHandler;// 删除一个cookie, 待删除的cookie对象可通过 'getAllCookies' 方法获取- (void)deleteCookie:(NSHTTPCookie *)cookie completionHandler:(nullable void (^)(void))completionHandler;/*! 添加一个观察者, 需要遵循协议 WKHTTPCookieStoreObserver 当cookie发送变化时, 会通过 WKHTTPCookieStoreObserver 的协议方法通知该观察者, 在使用完后需要移除观察者 */- (void)addObserver:(id&lt;WKHTTPCookieStoreObserver&gt;)observer;// 移除观察者- (void)removeObserver:(id&lt;WKHTTPCookieStoreObserver&gt;)observer;其中WKHTTPCookieStoreObserver协议：// 当cookie发生变动时触发- (void)cookiesDidChangeInCookieStore:(WKHTTPCookieStore *)cookieStore;WKWebsiteDataStoreWKWebsiteDataStore包含了网页中可以使用到的数据(cookies、沙盒缓存、内存缓存…)，一般是通过WKWebViewConfiguration进行相关设置。+ (WKWebsiteDataStore *)defaultDataStore;// 默认的data store// 如果为webView设置了这个data Store，则不会有数据缓存被写入文件// 当需要实现隐私浏览的时候，可使用这个+ (WKWebsiteDataStore *)nonPersistentDataStore;// 是否是可缓存数据的，只读@property (nonatomic, readonly, getter=isPersistent) BOOL persistent;// 获取所有可使用的数据类型+ (NSSet&lt;NSString *&gt; *)allWebsiteDataTypes;// 查找指定类型的缓存数据// 回调的值是WKWebsiteDataRecord的集合- (void)fetchDataRecordsOfTypes:(NSSet&lt;NSString *&gt; *)dataTypes completionHandler:(void (^)(NSArray&lt;WKWebsiteDataRecord *&gt; *))completionHandler;// 删除指定的纪录// 这里的参数是通过上面的方法查找到的WKWebsiteDataRecord实例获取的- (void)removeDataOfTypes:(NSSet&lt;NSString *&gt; *)dataTypes forDataRecords:(NSArray&lt;WKWebsiteDataRecord *&gt; *)dataRecords completionHandler:(void (^)(void))completionHandler;// 删除某时间后修改的某类型的数据- (void)removeDataOfTypes:(NSSet&lt;NSString *&gt; *)websiteDataTypes modifiedSince:(NSDate *)date completionHandler:(void (^)(void))completionHandler;// 保存的HTTP cookies@property (nonatomic, readonly) WKHTTPCookieStore *httpCookieStore其中WKWebsiteDataRecord网页数据记录类：@property (nonatomic, readonly, copy) NSString *displayName;// 展示名称, 通常是域名@property (nonatomic, readonly, copy) NSSet&lt;NSString *&gt; *dataTypes;// 包含的数据类型而dataTypes中的数据缓存类型：WK_EXTERN NSString * const WKWebsiteDataTypeDiskCache;// 硬盘缓存WK_EXTERN NSString * const WKWebsiteDataTypeMemoryCache;// 内存缓存WK_EXTERN NSString * const WKWebsiteDataTypeOfflineWebApplicationCache;// HTML离线web应用程序缓存WK_EXTERN NSString * const WKWebsiteDataTypeCookies;// cookiesWK_EXTERN NSString * const WKWebsiteDataTypeSessionStorage;// HTML会话存储WK_EXTERN NSString * const WKWebsiteDataTypeLocalStorage;// 本地缓存WK_EXTERN NSString * const WKWebsiteDataTypeWebSQLDatabases;// WebSQL 数据库WK_EXTERN NSString * const WKWebsiteDataTypeIndexedDBDatabases;//  IndexedDB 数据库删除指定时间的网页数据NSSet&lt;NSString *&gt; * data = [WKWebsiteDataStore allWebsiteDataTypes];NSDate *filterDate = [NSDate dateWithTimeIntervalSince1970:0];[[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:data modifiedSince:filterDate completionHandler:^{}];查找并且删除NSSet&lt;NSString *&gt; * data = [WKWebsiteDataStore allWebsiteDataTypes];[[WKWebsiteDataStore defaultDataStore] fetchDataRecordsOfTypes:data completionHandler:^(NSArray&lt;WKWebsiteDataRecord *&gt; * _Nonnull records) {    for (WKWebsiteDataRecord *record in records) {        if ([record.displayName isEqualToString:@"baidu"]) {            [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^{            }];        }}];Q&amp;A在多个WKWebView之间共享cookie原理就是所有的WKWebView使用同一个WKProcessPool。//1. 创建一个process poolprocessPool = [[WKProcessPool alloc] init];//2. 必须在init method中进行设置WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];config.processPool = processPool;webview = [[WKWebView alloc] initWithFrame:frame configuration:config];页面滚动速率- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {     scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;     //UIScrollViewDecelerationRateFast}视频自动播放设置是否允许自动播放，要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];config.requiresUserActionForMediaPlayback = NO; // 默认YESWKWebView 页面样式问题在 WKWebView 适配过程中，我们发现部分H5页面元素位置向下偏移或被拉伸变形：Use shrink-to-fit meta-tag &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, shrink-to-fit=no"&gt;白屏问题WKWebView是一个多进程组件,Network Loading 以及 UI Rendering 在其它进程中执行。打开 WKWebView 后，App 进程内存消耗下降，Other Process 的内存占用会增加。总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。1. 使用WKNavigtionDelegate代理方法重新加载：当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。//进程被终止时调用- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView{    [webView reload];}2. 检测 webView.title 是否为空在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空, 因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。适配网页文本大小            适配前      适配后｜                              //适配网页文本大小WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];NSString *jSString = @"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);";//用于进行JavaScript注入WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jSString injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];[config.userContentController addUserScript:wkUScript];网页进度条WKWebView系统属性：// 0.0~1.0@property (nonatomic, readonly) double estimatedProgress;通过KVO去监听进度值:- (void)viewDidLoad {    [super viewDidLoad];    [self.view addSubview:self.progressView];    [self.webView addObserver:self forKeyPath:NSStringFromSelector(@selector(estimatedProgress)) options:0 context:nil];}- (void)dealloc{    [_webView removeObserver:self forKeyPath:NSStringFromSelector(@selector(estimatedProgress))];}#pragma mark - KVO-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{    if ([keyPath isEqualToString:NSStringFromSelector(@selector(estimatedProgress))] &amp;&amp; object == _webView){        NSLog(@"网页加载进度 = %f",_webView.estimatedProgress);        self.progressView.progress = _webView.estimatedProgress;        if (_webView.estimatedProgress &gt;= 1.0f) {            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{                self.progressView.progress = 0;            });        }    }else{        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];    }}解决WKWebView不能打开任何有target="_blank"（开一个新的窗口）属性的网页- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {    if (!navigationAction.targetFrame.isMainFrame) {        [webView loadRequest:navigationAction.request];    }    return nil;}JS调用OC的方法方式1:window.webkit.messageHandlers项目中兼容以前的OCR接入。当JS调用OC方法时：其中jsToOcNoPrams、jsToOcWithPrams两个名称是两端统一的。function jsToOcFunction1(){    window.webkit.messageHandlers.jsToOcNoPrams.postMessage({});}function jsToOcFunction2(){    window.webkit.messageHandlers.jsToOcWithPrams.postMessage({"params":"我是参数"});}原生实现方式：@interface SEGWebViewViewController ()&lt;WKUIDelegate,WKNavigationDelegate,WKScriptMessageHandler&gt;@end@implementation SEGWebViewViewController//被自定义的WKScriptMessageHandler在回调方法里通过代理回调回来，绕了一圈就是为了解决内存不释放的问题//通过接收JS传出消息的name进行捕捉的回调方法- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{    NSLog(@"name:%@\\\\n body:%@\\\\n frameInfo:%@\\\\n",message.name,message.body,message.frameInfo);    //用message.body获得JS传出的参数体    NSDictionary * parameter = message.body;    //JS调用OC    if([message.name isEqualToString:@"jsToOcNoPrams"]){        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"js调用到了oc" message:@"不带参数" preferredStyle:UIAlertControllerStyleAlert];        [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {        }])];        [self presentViewController:alertController animated:YES completion:nil];            }else if([message.name isEqualToString:@"jsToOcWithPrams"]){        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"js调用到了oc" message:parameter[@"params"] preferredStyle:UIAlertControllerStyleAlert];        [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {        }])];        [self presentViewController:alertController animated:YES completion:nil];    }    }- (WKWebView *)webView{    if(_webView == nil){                //创建网页配置对象        WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];        //这个类主要用来做native与JavaScript的交互管理        WKUserContentController * wkUController = [[WKUserContentController alloc] init];                //自定义的WKScriptMessageHandler 是为了解决内存不释放的问题        WeakWebViewScriptMessageDelegate *weakScriptMessageDelegate = [[WeakWebViewScriptMessageDelegate alloc] initWithDelegate:self];        //注册一个name为jsToOcNoPrams的js方法 设置处理接收JS方法的对象        [wkUController addScriptMessageHandler:weakScriptMessageDelegate  name:@"jsToOcNoPrams"];        [wkUController addScriptMessageHandler:weakScriptMessageDelegate  name:@"jsToOcWithPrams"];                config.userContentController = wkUController;                        _webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT) configuration:config];        _webView.UIDelegate = self;// UI代理        _webView.navigationDelegate = self;// 导航代理    }    return _webView;}- (void)dealloc{    //移除注册的js方法    [[_webView configuration].userContentController removeScriptMessageHandlerForName:@"jsToOcNoPrams"];    [[_webView configuration].userContentController removeScriptMessageHandlerForName:@"jsToOcWithPrams"];}@end自定义的消息句柄：@interface WeakWebViewScriptMessageDelegate : NSObject&lt;WKScriptMessageHandler&gt;//WKScriptMessageHandler 这个协议类专门用来处理JavaScript调用原生OC的方法@property (nonatomic, weak) id&lt;WKScriptMessageHandler&gt; scriptDelegate;@end@implementation WeakWebViewScriptMessageDelegate- (instancetype)initWithDelegate:(id&lt;WKScriptMessageHandler&gt;)scriptDelegate {    self = [super init];    if (self) {        _scriptDelegate = scriptDelegate;    }    return self;}#pragma mark - WKScriptMessageHandler//遵循WKScriptMessageHandler协议，必须实现如下方法，然后把方法向外传递//通过接收JS传出消息的name进行捕捉的回调方法- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {        if ([self.scriptDelegate respondsToSelector:@selector(userContentController:didReceiveScriptMessage:)]) {        [self.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];    }}@end也可以直接使用系统定义的WKScriptMessageHandler来实现。方式2:window.location.href当JS调用OC方法时：function jsToOcFunction3(){    var query = {      fn: 'uhomeNativeApi.cameraCb'    };    window.location.href = 'uhomeoc://system.camera?params=' + JSON.stringify(query);}这是直接发起连接跳转，可以通过WKNavigationDelegate代理来拦截。- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{        NSString * scheme = navigationAction.request.URL.scheme;    NSString * host = navigationAction.request.URL.host;    NSString * query = [navigationAction.request.URL.query stringByURLDecode];    if (scheme &amp;&amp; host &amp;&amp; [scheme rangeOfString:@"uhomeoc"].location != NSNotFound){        if ([host rangeOfString:@"system.camera"].location != NSNotFound) { // 使用原生系统功能：相机            [self segJSSystemCameraWithQuery:query request:navigationAction.request.URL];            decisionHandler(WKNavigationActionPolicyCancel);            return;        }    }    decisionHandler(WKNavigationActionPolicyAllow);}OC调用JS的方法假设JS中存在方法，需要用原生方法去执行：function changeColor(parameter){    document.body.style.backgroundColor = randomColor();    alert(parameter);}OC原生方法：//OC调用JS- (void)ocToJs{    //changeColor()是JS方法名，completionHandler是异步回调block    NSString *jsString = [NSString stringWithFormat:@"changeColor('%@')", @"Js颜色参数"];    [_webView evaluateJavaScript:jsString completionHandler:^(id _Nullable data, NSError * _Nullable error) {        NSLog(@"改变HTML的背景色");    }];}scalesPageToFitUIWebView:@property (nonatomic) BOOL scalesPageToFit;WKWebView:-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation{    NSString *injectionJSString = @"var script = document.createElement('meta');"    "script.name = 'viewport';"    "script.content=\"width=device-width, user-scalable=no\";"    "document.getElementsByTagName('head')[0].appendChild(script);";    [webView evaluateJavaScript:injectionJSString completionHandler:nil];}设置userAgent_webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, WK_SCREEN_WIDTH(), WK_SCREEN_HEIGHT()) configuration:config];[_webView evaluateJavaScript:@"navigator.userAgent" completionHandler:^(id result, NSError *error) {    NSString *userAgent = result;    NSString *newUserAgent = [userAgent stringByAppendingString:@"/uhome_iPhone"];        NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:newUserAgent, @"UserAgent", nil];    [[NSUserDefaults standardUserDefaults] registerDefaults:dictionary];    [[NSUserDefaults standardUserDefaults] synchronize];        if (@available(iOS 9.0, *)) {        [self-&gt;_webView setCustomUserAgent:newUserAgent];    } else {        [self-&gt;_webView setValue:newUserAgent forKey:@"applicationNameForUserAgent"];    }}];WKBackForwardList 的使用WKBackForwardList类可以通过前进或者后退来进行对网页视图的访问。@interface WKBackForwardList : NSObject@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *currentItem;@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *backItem;@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *forwardItem;- (nullable WKBackForwardListItem *)itemAtIndex:(NSInteger)index;@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *backList;@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *forwardList;@end在WKWebView中支持WKBackForwardList的属性和方法：@property (nonatomic, readonly, strong) WKBackForwardList *backForwardList;@property (nonatomic) BOOL allowsBackForwardNavigationGestures;@property (nonatomic, readonly) BOOL canGoBack;@property (nonatomic, readonly) BOOL canGoForward;- (nullable WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item;- (nullable WKNavigation *)goBack;- (nullable WKNavigation *)goForward;// 可以在执行 goBack、goForward之前先把loading停了。- (void)stopLoading;- (nullable WKNavigation *)reload;通过KVO来监控@"canGoBack"、@"canGoForward"属性，动态获取页面goBack、goForward情况。-(void)segAddKVO{    [self.webView addObserver:self forKeyPath:@"canGoBack" options:NSKeyValueObservingOptionNew context:nil];    [self.webView addObserver:self forKeyPath:@"canGoForward" options:NSKeyValueObservingOptionNew context:nil];}-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{    if (object == self.webView &amp;&amp; [keyPath isEqualToString:@"canGoBack"]){        [self updateBottomViewGoBackButtonStatus];    }else if (object == self.webView &amp;&amp; [keyPath isEqualToString:@"canGoForward"]){        [self updateBottomViewGoForwardButtonStatus];    }else{        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];    }}- (void)dealloc{    [_webView removeObserver:self forKeyPath:@"canGoBack"];    [_webView removeObserver:self forKeyPath:@"canGoForward"];}WKBackForwardListItem@interface WKBackForwardListItem : NSObject- (instancetype)init NS_UNAVAILABLE;@property (readonly, copy) NSURL *URL;@property (nullable, readonly, copy) NSString *title;@property (readonly, copy) NSURL *initialURL;@endCookiesJS原生方法可以获取cookie：document.cookie获取cookie1.从NSHttpCookieStorage、WKHttpCookieStore中获取cookie：+ (void)logCookiesFromHTTPCookieStore{    if (@available(iOS 11.0, *)) {        WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];        [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * cookies) {            [cookies enumerateObjectsUsingBlock:^(NSHTTPCookie * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {                NSLog(@"--&gt;count:%zd; name:%@; value:%@",cookies.count, obj.name, obj.value);                            }];        }];    }    else {        NSArray *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;        for (NSHTTPCookie *cookie in cookieJar) {            NSLog(@"--&gt;count:%zd; name:%@; value:%@",cookieJar.count, cookie.name, cookie.value);        }    }}2.从请求头中获取cookie：- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {    NSArray *cookies = [NSHTTPCookie cookiesWithResponseHeaderFields:[navigationAction.request allHTTPHeaderFields] forURL:navigationAction.request.URL];    decisionHandler(WKNavigationActionPolicyAllow);}3.通过JS方法获取cookie：- (void)ocToJs{    //changeColor()是JS方法名，completionHandler是异步回调block    NSString *jsString = [NSString stringWithFormat:@"alert(document.cookie)"];    [_webView evaluateJavaScript:jsString completionHandler:^(id _Nullable data, NSError * _Nullable error) {    }];}4.获取响应头中的cookie：- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{    NSHTTPURLResponse *response = navigationResponse.response;    // FIXME:获取Cookie!!!    NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];    // 读取wkwebview中的cookie 方法1    for (NSHTTPCookie *cookie in cookies) {        //[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];        NSLog(@"--&gt;wkwebview中的cookie:%@", cookie);    }        // -------------------- 分割线    // 读取wkwebview中的cookie 方法2 读取Set-Cookie字段    NSString *cookieString = [[response allHeaderFields] valueForKey:@"Set-Cookie"];    NSLog(@"wkwebview中的cookie:%@", cookieString);    // 看看存入到了NSHTTPCookieStorage了没有    NSHTTPCookieStorage *cookieJar2 = [NSHTTPCookieStorage sharedHTTPCookieStorage];    for (NSHTTPCookie *cookie in cookieJar2.cookies) {        NSLog(@"NSHTTPCookieStorage中的cookie%@", cookie);    }        NSString * urlStr = navigationResponse.response.URL.absoluteString;    NSLog(@"当前跳转地址：%@",urlStr);    //允许跳转    decisionHandler(WKNavigationResponsePolicyAllow);    //不允许跳转    //decisionHandler(WKNavigationResponsePolicyCancel);}添加cookie- (void)addCookie {    NSDictionary *mCookProperties = @{    NSHTTPCookieDomain: @".lilongcnc.cc",    NSHTTPCookiePath: @"/",    NSHTTPCookieName: @"laurenKey",    NSHTTPCookieValue:  @"laurenValue",    };    NSHTTPCookie *myCookie = [NSHTTPCookie cookieWithProperties:mCookProperties];    if (@available(iOS 11.0, *)) {        WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];        [store.httpCookieStore setCookie:myCookie completionHandler:^{        }];                    } else {        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:myCookie];        [[NSUserDefaults standardUserDefaults] synchronize];    }}同步cookie在iOS11以下的版本中，WKWebView并没有类似UIWebView中NSHTTPCookieStorage这样的可以直接设置和存储Cookie的官方类。但是在各个App的实际开发过程中，给HTML5后台传入Cookie进行身份校验等属于最基本的操作，正是因为不能方便设置Cookie的原因，在本文发布的时候，很多大厂App的核心web业务并没有使用WKWebView，仍然是UIWebView。iOS11开始，苹果意识到了这个问题，做了妥协，新增WKHTTPCookieStorage来帮助开发者解决Cookie问题，虽然方便了，但是API仍然不稳定，比如iOS11.3的时候就出现了一些变动。在UIWebView中，可以通过NSHttpCookieStorage来管理Cookie，对Cookie进行增删改查。当把Cookie添加到NSHttpCookieStorage中后，webView在发起请求的时候会自动从NSHttpCookieStorage中取出Cookie添加到request Header中，并且这个操作是零延迟的。也就是说，你第一行代码添加Cookie到NSHttpCookieStorage中，第二行代码loadRequest:，发起的请求中是带有你设置的Cookie的。在WKWebView中，WKWebView实例也会将 Cookie 存储于 NSHTTPCookieStorage中，但存储时机有延迟。NSHttpCookieStorage对WKWebView而言，只能管理Cookie，但是没有了零延迟自动同步到request Header这一关键特性。WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。            版本      方案                  &lt;iOS11      使用NSHttpCookieStorage管理cookie。新页面请求：在loadRequest之前把cookie添加到Request Header中。              iOS11~iOS12      WKHttpCookieStorage管理，在loadRequest之前写入本地cookie              iOS13      WKHttpCookieStorage管理，同步机制变化，不能及时同步。首次请求:在loadRequest之前写入本地cookie      &lt;iOS11  使用NSHttpCookieStorage管理cookie。  请求新WebView页面请求：在loadRequest之前把cookie添加到Request Header中。  页面跳转：JS写入document.cookie中【解决后续页面(同域)Ajax、iframe 请求的 Cookie 问题】  document.cookie()无法跨域设置 cookie-(void)loadData {    if (@available(iOS 13.0, *)) { /*13*/            }else if (@available(iOS 11.0, *)){ /*11~12*/            }else{ /* 8~10:先把cookie添加到`Request Header`中 */        NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://h5.qzone.qq.com/mqzone/index"]];                [request addValue:@"skey=skeyValue" forHTTPHeaderField:@"Cookie"];        [_webView loadRequest:request];    }}设置document.cookie：WKUserContentController* userContentController = [WKUserContentController new] ;WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource: @"document.cookie = 'skey=skeyValue';" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; [userContentController addUserScript:cookieScript];config.userContentController = userContentController;iOS11~iOS12iOS11.0推出了WKHTTPCookieStore，效果和NSHttpCookieStorage一样，是零延迟。在请求发起的时候，我们只需要将Cookie设置到WKHTTPCookieStore就可以了。- (void)loadData {    if (@available(iOS 11.0, *)) {        // 1. 设置Cookie        NSArray *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;        WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];        [store.httpCookieStore setCookie:cookieJar completionHandler:^{            NSLog(@"cookie添加成功");        }];        // 2. 加载请求        [self.wkwebView loadRequest: request];    }}iOS13在iOS13中可能遇到的问题：WKHTTPCookieStore设置Cookie之后，第一次发起请求Cookie会丢失，第二次及以后的请求的Cookie没有问题。可以在login之后先同步一次cookie：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {   WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];    [store.httpCookieStore setCookie:cookie completionHandler:^{        NSLog(@"cookie添加成功");    }];}iOS13 新方法TODO  导航栏新增页面刷新、用系统浏览器打开的功能。  网页组件建议新增goBack、goForward，样式可以参考微信。参考资料  WKWebView的使用–API篇  WKWebView User Agent、跨域、重定向及其它  IOS进阶之WKWebView  WKWebView 那些坑  WBWebViewConsole  stackoverflow:Can I set the cookies to be used by a WKWebView?]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[开发证书管理]]></title>
      <url>/ios/2020/01/01/ios-devaccount/</url>
      <content type="text"><![CDATA[Identifiers  Description:  Bundle ID:          explicit(Check)        Capabilities:          App Groups : APP数据共享      Network Extensions : 网络拓展      证书签名请求(Certificate Signing Request(CSR))CSR官方教程  启动位于 /Applications/Utilities 中的“钥匙串访问”。  选取“钥匙串访问”&gt;“证书助理”&gt;“从证书颁发机构请求证书”。  在“证书助理”对话框中，在“用户电子邮件地址”栏位中输入电子邮件地址。  在“常用名称”栏位中，输入密钥的名称 (例如，Gita Kumar Dev Key)。  将“CA 电子邮件地址”栏位留空。  选取“存储到磁盘”，然后点按“继续”。证书(Certificates)生成步骤：+ -&gt; Certificates -&gt; CSR -&gt; Download。  Software          Apple Development:开发证书。平台: iOS、macOS、tvOS、watchOS。用于iOS11系统以上      Apple Distribution:(App Store、Ad Hoc)发布证书。平台: iOS、macOS、tvOS、watchOS。用于iOS11系统以上      iOS App Development: 内部开发证书。平台: iOS      iOS Distribution: (App Store、Ad Hoc)发布证书。平台: iOS      Mac Development: 内部开发证书。平台: Mac      Mac App Distribution: 提交给 Mac App Store 的发布证书。      Mac Installer Distribution: 提交给 Mac App Store 的PKG签名发布证书。      Developer ID Installer: 在 Mac App Store之外分发的 证书，用于开发者打包+签名。      Developer ID Application:  在 Mac App Store之外分发的 PKG签名发布证书        Services          Apple Push Notification service SSL :  Apple(Sandbox)开发环境推送证书                  Platform : iOS、macOS          App ID : 这里的ID是下拉选择，在Identifiers模块创建的ID。                    Apple Push Notification service SSL : Apple(Sandbox &amp; Production)生产环境推送证书      macOS Apple Push Notification service SSL (Production) : macOS(Production)推送证书      Pass Type ID Certificate : 通过类型ID证书-用于电子钱包      Website Push ID Certificate : 网站推送ID证书      WatchKit Services Certificate : WatchKit服务证书      VoIP Services Certificate : VoIP服务证书      Apple Pay Payment Processing Certificate : Apple Pay付款处理证书      Apple Pay Merchant Identity Certificate : Apple Pay商家身份证明      配置文件(Profiles)通过配置文件，可以将应用程序安装到设备上。供应配置文件包括签名证书，设备标识符和应用程序ID。可以通过测试人员的UDID+Profiles把IPA包发给远程的人使用。密钥(Keys)创建密钥后，您可以为该密钥配置，认证和使用一项或多项Apple服务。与证书不同，密钥不会过期，可以在创建密钥后对其进行修改以访问更多服务。结果会生成一个.p8文件。  Key Name: 随便填  ENABLE Server          Apple Push Notifications service (APNs) : 消息推送服务      DeviceCheck : 设备检查 - 访问关联服务器可以在其业务逻辑中使用的每个设备，每个开发人员的数据。一键用于所有应用程序。      错误收集Automatic signing is unable to resolve an issue with the "xxx" target's entitlements.Switch to manual signing and resolve the issue by downloading a matching provisioning profile from the developer website. Alternatively, to continue using automatic signing, remove these entitlements from your entitlements file and their associated functionality from your code.Provisioning profile "iOS Team Provisioning Profile: com.xxxxxx" doesn't match the entitlements file's value for the keychain-access-groups entitlement.修改配置中的Keychain Sharing中的值。参考资料  Apple Store Connection 帮助]]></content>
      <categories>
        
          <category> ios </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
